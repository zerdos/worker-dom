"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ChildListProcessor = void 0;

var _TransferrableMutation = require("../../transfer/TransferrableMutation");

var _eventSubscription = require("./event-subscription");

/**
 * Copyright 2019 The AMP HTML Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ChildListProcessor = (strings, {
  getNode
}, workerContext, objectContext, config) => {
  const allowedExecution = config.executorsAllowed.includes(_TransferrableMutation.TransferrableMutationType.CHILD_LIST);
  return {
    execute(mutations, startPosition, allowedMutation) {
      const appendNodeCount = mutations[startPosition + _TransferrableMutation.ChildListMutationIndex.AppendedNodeCount];
      const removeNodeCount = mutations[startPosition + _TransferrableMutation.ChildListMutationIndex.RemovedNodeCount];

      if (allowedExecution && allowedMutation) {
        const targetIndex = mutations[startPosition + _TransferrableMutation.ChildListMutationIndex.Target];
        const target = getNode(targetIndex);

        if (target) {
          if (removeNodeCount > 0) {
            mutations.slice(startPosition + _TransferrableMutation.ChildListMutationIndex.Nodes + appendNodeCount, startPosition + _TransferrableMutation.ChildListMutationIndex.Nodes + appendNodeCount + removeNodeCount).forEach(removeId => {
              const node = getNode(removeId);

              if (node) {
                node.remove();
              } else {
                console.error(`CHILD_LIST: getNode(${removeId}) is null.`);
              }
            });
          }

          if (appendNodeCount > 0) {
            mutations.slice(startPosition + _TransferrableMutation.ChildListMutationIndex.Nodes, startPosition + _TransferrableMutation.ChildListMutationIndex.Nodes + appendNodeCount).forEach(addId => {
              const nextSibling = mutations[startPosition + _TransferrableMutation.ChildListMutationIndex.NextSibling];
              const newNode = getNode(addId);

              if (newNode) {
                // TODO: Handle this case ---
                // Transferred nodes that are not stored were previously removed by the sanitizer.
                target.insertBefore(newNode, nextSibling && getNode(nextSibling) || null);
                (0, _eventSubscription.applyDefaultInputListener)(workerContext, newNode);
                (0, _eventSubscription.sendValueChangeOnAttributeMutation)(workerContext, newNode);
              }
            });
          }
        } else {
          console.error(`CHILD_LIST: getNode(${targetIndex}) is null.`);
        }
      }

      return startPosition + _TransferrableMutation.ChildListMutationIndex.End + appendNodeCount + removeNodeCount;
    },

    print(mutations, startPosition) {
      const targetIndex = mutations[startPosition + _TransferrableMutation.ChildListMutationIndex.Target];
      const target = getNode(targetIndex);
      const appendNodeCount = mutations[startPosition + _TransferrableMutation.ChildListMutationIndex.AppendedNodeCount];
      const removeNodeCount = mutations[startPosition + _TransferrableMutation.ChildListMutationIndex.RemovedNodeCount];
      const removedNodes = Array.from(mutations.slice(startPosition + _TransferrableMutation.ChildListMutationIndex.Nodes + appendNodeCount, startPosition + _TransferrableMutation.ChildListMutationIndex.Nodes + appendNodeCount + removeNodeCount)).map(index => getNode(index) || index);
      const addedNodes = Array.from(mutations.slice(startPosition + _TransferrableMutation.ChildListMutationIndex.Nodes, startPosition + _TransferrableMutation.ChildListMutationIndex.Nodes + appendNodeCount)).map(index => getNode(index) || index);
      return {
        target,
        allowedExecution,
        nextSibling: getNode(mutations[startPosition + _TransferrableMutation.ChildListMutationIndex.NextSibling]) || null,
        previousSibling: getNode(mutations[startPosition + _TransferrableMutation.ChildListMutationIndex.PreviousSibling]) || null,
        addedNodes,
        removedNodes
      };
    }

  };
};

exports.ChildListProcessor = ChildListProcessor;