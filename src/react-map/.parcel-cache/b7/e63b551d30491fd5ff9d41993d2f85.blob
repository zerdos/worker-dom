// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function(modules, cache, entry, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject.parcelRequire === 'function' &&
    globalObject.parcelRequire;
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x) {
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function(id, exports) {
    modules[id] = [
      function(require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  globalObject.parcelRequire = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function() {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"64c1770b35b04eb343009bb27a752262":[function(require,module,exports) {
var Refresh = require('react-refresh/runtime');

Refresh.injectIntoGlobalHook(window);

window.$RefreshReg$ = function () {};

window.$RefreshSig$ = function () {
  return function (type) {
    return type;
  };
};
},{"react-refresh/runtime":"cc753e404649308295dd758d0c09f05d"}],"cc753e404649308295dd758d0c09f05d":[function(require,module,exports) {
'use strict';

if ("development" === 'production') {
  module.exports = require('./cjs/react-refresh-runtime.production.min.js');
} else {
  module.exports = require('./cjs/react-refresh-runtime.development.js');
}
},{"./cjs/react-refresh-runtime.development.js":"1f47ef9c6ac8c86c3d1ed121f4d58e3b"}],"1f47ef9c6ac8c86c3d1ed121f4d58e3b":[function(require,module,exports) {
/** @license React v0.6.0
 * react-refresh-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';

if ("development" !== "production") {
  (function () {
    'use strict'; // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
    // nor polyfill, then a plain number is used for performance.

    var hasSymbol = typeof Symbol === 'function' && Symbol.for; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
    // (unstable) APIs that have been removed. Can we remove the symbols?

    var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
    var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
    var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map; // We never remove these associations.
    // It's OK to reference families, but use WeakMap/Set for types.

    var allFamiliesByID = new Map();
    var allFamiliesByType = new PossiblyWeakMap();
    var allSignaturesByType = new PossiblyWeakMap(); // This WeakMap is read by React, so we only put families
    // that have actually been edited here. This keeps checks fast.
    // $FlowIssue

    var updatedFamiliesByType = new PossiblyWeakMap(); // This is cleared on every performReactRefresh() call.
    // It is an array of [Family, NextType] tuples.

    var pendingUpdates = []; // This is injected by the renderer via DevTools global hook.

    var helpersByRendererID = new Map();
    var helpersByRoot = new Map(); // We keep track of mounted roots so we can schedule updates.

    var mountedRoots = new Set(); // If a root captures an error, we add its element to this Map so we can retry on edit.

    var failedRoots = new Map();
    var didSomeRootFailOnMount = false;

    function computeFullKey(signature) {
      if (signature.fullKey !== null) {
        return signature.fullKey;
      }

      var fullKey = signature.ownKey;
      var hooks;

      try {
        hooks = signature.getCustomHooks();
      } catch (err) {
        // This can happen in an edge case, e.g. if expression like Foo.useSomething
        // depends on Foo which is lazily initialized during rendering.
        // In that case just assume we'll have to remount.
        signature.forceReset = true;
        signature.fullKey = fullKey;
        return fullKey;
      }

      for (var i = 0; i < hooks.length; i++) {
        var hook = hooks[i];

        if (typeof hook !== 'function') {
          // Something's wrong. Assume we need to remount.
          signature.forceReset = true;
          signature.fullKey = fullKey;
          return fullKey;
        }

        var nestedHookSignature = allSignaturesByType.get(hook);

        if (nestedHookSignature === undefined) {
          // No signature means Hook wasn't in the source code, e.g. in a library.
          // We'll skip it because we can assume it won't change during this session.
          continue;
        }

        var nestedHookKey = computeFullKey(nestedHookSignature);

        if (nestedHookSignature.forceReset) {
          signature.forceReset = true;
        }

        fullKey += '\n---\n' + nestedHookKey;
      }

      signature.fullKey = fullKey;
      return fullKey;
    }

    function haveEqualSignatures(prevType, nextType) {
      var prevSignature = allSignaturesByType.get(prevType);
      var nextSignature = allSignaturesByType.get(nextType);

      if (prevSignature === undefined && nextSignature === undefined) {
        return true;
      }

      if (prevSignature === undefined || nextSignature === undefined) {
        return false;
      }

      if (computeFullKey(prevSignature) !== computeFullKey(nextSignature)) {
        return false;
      }

      if (nextSignature.forceReset) {
        return false;
      }

      return true;
    }

    function isReactClass(type) {
      return type.prototype && type.prototype.isReactComponent;
    }

    function canPreserveStateBetween(prevType, nextType) {
      if (isReactClass(prevType) || isReactClass(nextType)) {
        return false;
      }

      if (haveEqualSignatures(prevType, nextType)) {
        return true;
      }

      return false;
    }

    function resolveFamily(type) {
      // Only check updated types to keep lookups fast.
      return updatedFamiliesByType.get(type);
    }

    function performReactRefresh() {
      {
        if (pendingUpdates.length === 0) {
          return null;
        }

        var staleFamilies = new Set();
        var updatedFamilies = new Set();
        var updates = pendingUpdates;
        pendingUpdates = [];
        updates.forEach(function (_ref) {
          var family = _ref[0],
              nextType = _ref[1]; // Now that we got a real edit, we can create associations
          // that will be read by the React reconciler.

          var prevType = family.current;
          updatedFamiliesByType.set(prevType, family);
          updatedFamiliesByType.set(nextType, family);
          family.current = nextType; // Determine whether this should be a re-render or a re-mount.

          if (canPreserveStateBetween(prevType, nextType)) {
            updatedFamilies.add(family);
          } else {
            staleFamilies.add(family);
          }
        }); // TODO: rename these fields to something more meaningful.

        var update = {
          updatedFamilies: updatedFamilies,
          // Families that will re-render preserving state
          staleFamilies: staleFamilies // Families that will be remounted

        };
        helpersByRendererID.forEach(function (helpers) {
          // Even if there are no roots, set the handler on first update.
          // This ensures that if *new* roots are mounted, they'll use the resolve handler.
          helpers.setRefreshHandler(resolveFamily);
        });
        var didError = false;
        var firstError = null;
        failedRoots.forEach(function (element, root) {
          var helpers = helpersByRoot.get(root);

          if (helpers === undefined) {
            throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');
          }

          try {
            helpers.scheduleRoot(root, element);
          } catch (err) {
            if (!didError) {
              didError = true;
              firstError = err;
            } // Keep trying other roots.

          }
        });
        mountedRoots.forEach(function (root) {
          var helpers = helpersByRoot.get(root);

          if (helpers === undefined) {
            throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');
          }

          try {
            helpers.scheduleRefresh(root, update);
          } catch (err) {
            if (!didError) {
              didError = true;
              firstError = err;
            } // Keep trying other roots.

          }
        });

        if (didError) {
          throw firstError;
        }

        return update;
      }
    }

    function register(type, id) {
      {
        if (type === null) {
          return;
        }

        if (typeof type !== 'function' && typeof type !== 'object') {
          return;
        } // This can happen in an edge case, e.g. if we register
        // return value of a HOC but it returns a cached component.
        // Ignore anything but the first registration for each type.


        if (allFamiliesByType.has(type)) {
          return;
        } // Create family or remember to update it.
        // None of this bookkeeping affects reconciliation
        // until the first performReactRefresh() call above.


        var family = allFamiliesByID.get(id);

        if (family === undefined) {
          family = {
            current: type
          };
          allFamiliesByID.set(id, family);
        } else {
          pendingUpdates.push([family, type]);
        }

        allFamiliesByType.set(type, family); // Visit inner types because we might not have registered them.

        if (typeof type === 'object' && type !== null) {
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              register(type.render, id + '$render');
              break;

            case REACT_MEMO_TYPE:
              register(type.type, id + '$type');
              break;
          }
        }
      }
    }

    function setSignature(type, key) {
      var forceReset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var getCustomHooks = arguments.length > 3 ? arguments[3] : undefined;
      {
        allSignaturesByType.set(type, {
          forceReset: forceReset,
          ownKey: key,
          fullKey: null,
          getCustomHooks: getCustomHooks || function () {
            return [];
          }
        });
      }
    } // This is lazily called during first render for a type.
    // It captures Hook list at that time so inline requires don't break comparisons.


    function collectCustomHooksForSignature(type) {
      {
        var signature = allSignaturesByType.get(type);

        if (signature !== undefined) {
          computeFullKey(signature);
        }
      }
    }

    function getFamilyByID(id) {
      {
        return allFamiliesByID.get(id);
      }
    }

    function getFamilyByType(type) {
      {
        return allFamiliesByType.get(type);
      }
    }

    function findAffectedHostInstances(families) {
      {
        var affectedInstances = new Set();
        mountedRoots.forEach(function (root) {
          var helpers = helpersByRoot.get(root);

          if (helpers === undefined) {
            throw new Error('Could not find helpers for a root. This is a bug in React Refresh.');
          }

          var instancesForRoot = helpers.findHostInstancesForRefresh(root, families);
          instancesForRoot.forEach(function (inst) {
            affectedInstances.add(inst);
          });
        });
        return affectedInstances;
      }
    }

    function injectIntoGlobalHook(globalObject) {
      {
        // For React Native, the global hook will be set up by require('react-devtools-core').
        // That code will run before us. So we need to monkeypatch functions on existing hook.
        // For React Web, the global hook will be set up by the extension.
        // This will also run before us.
        var hook = globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__;

        if (hook === undefined) {
          // However, if there is no DevTools extension, we'll need to set up the global hook ourselves.
          // Note that in this case it's important that renderer code runs *after* this method call.
          // Otherwise, the renderer will think that there is no global hook, and won't do the injection.
          var nextID = 0;
          globalObject.__REACT_DEVTOOLS_GLOBAL_HOOK__ = hook = {
            supportsFiber: true,
            inject: function (injected) {
              return nextID++;
            },
            onCommitFiberRoot: function (id, root, maybePriorityLevel, didError) {},
            onCommitFiberUnmount: function () {}
          };
        } // Here, we just want to get a reference to scheduleRefresh.


        var oldInject = hook.inject;

        hook.inject = function (injected) {
          var id = oldInject.apply(this, arguments);

          if (typeof injected.scheduleRefresh === 'function' && typeof injected.setRefreshHandler === 'function') {
            // This version supports React Refresh.
            helpersByRendererID.set(id, injected);
          }

          return id;
        }; // We also want to track currently mounted roots.


        var oldOnCommitFiberRoot = hook.onCommitFiberRoot;

        hook.onCommitFiberRoot = function (id, root, maybePriorityLevel, didError) {
          var helpers = helpersByRendererID.get(id);

          if (helpers === undefined) {
            return;
          }

          helpersByRoot.set(root, helpers);
          var current = root.current;
          var alternate = current.alternate; // We need to determine whether this root has just (un)mounted.
          // This logic is copy-pasted from similar logic in the DevTools backend.
          // If this breaks with some refactoring, you'll want to update DevTools too.

          if (alternate !== null) {
            var wasMounted = alternate.memoizedState != null && alternate.memoizedState.element != null;
            var isMounted = current.memoizedState != null && current.memoizedState.element != null;

            if (!wasMounted && isMounted) {
              // Mount a new root.
              mountedRoots.add(root);
              failedRoots.delete(root);
            } else if (wasMounted && isMounted) {// Update an existing root.
              // This doesn't affect our mounted root Set.
            } else if (wasMounted && !isMounted) {
              // Unmount an existing root.
              mountedRoots.delete(root);

              if (didError) {
                // We'll remount it on future edits.
                // Remember what was rendered so we can restore it.
                failedRoots.set(root, alternate.memoizedState.element);
              } else {
                helpersByRoot.delete(root);
              }
            } else if (!wasMounted && !isMounted) {
              if (didError && !failedRoots.has(root)) {
                // The root had an error during the initial mount.
                // We can't read its last element from the memoized state
                // because there was no previously committed alternate.
                // Ideally, it would be nice if we had a way to extract
                // the last attempted rendered element, but accessing the update queue
                // would tie this package too closely to the reconciler version.
                // So instead, we just set a flag.
                // TODO: Maybe we could fix this as the same time as when we fix
                // DevTools to not depend on `alternate.memoizedState.element`.
                didSomeRootFailOnMount = true;
              }
            }
          } else {
            // Mount a new root.
            mountedRoots.add(root);
          }

          return oldOnCommitFiberRoot.apply(this, arguments);
        };
      }
    }

    function hasUnrecoverableErrors() {
      return didSomeRootFailOnMount;
    } // Exposed for testing.


    function _getMountedRootCount() {
      {
        return mountedRoots.size;
      }
    } // This is a wrapper over more primitive functions for setting signature.
    // Signatures let us decide whether the Hook order has changed on refresh.
    //
    // This function is intended to be used as a transform target, e.g.:
    // var _s = createSignatureFunctionForTransform()
    //
    // function Hello() {
    //   const [foo, setFoo] = useState(0);
    //   const value = useCustomHook();
    //   _s(); /* Second call triggers collecting the custom Hook list.
    //          * This doesn't happen during the module evaluation because we
    //          * don't want to change the module order with inline requires.
    //          * Next calls are noops. */
    //   return <h1>Hi</h1>;
    // }
    //
    // /* First call specifies the signature: */
    // _s(
    //   Hello,
    //   'useState{[foo, setFoo]}(0)',
    //   () => [useCustomHook], /* Lazy to avoid triggering inline requires */
    // );


    function createSignatureFunctionForTransform() {
      {
        var call = 0;
        var savedType;
        var hasCustomHooks;
        return function (type, key, forceReset, getCustomHooks) {
          switch (call++) {
            case 0:
              savedType = type;
              hasCustomHooks = typeof getCustomHooks === 'function';
              setSignature(type, key, forceReset, getCustomHooks);
              break;

            case 1:
              if (hasCustomHooks) {
                collectCustomHooksForSignature(savedType);
              }

              break;
          }

          return type;
        };
      }
    }

    function isLikelyComponentType(type) {
      {
        switch (typeof type) {
          case 'function':
            {
              // First, deal with classes.
              if (type.prototype != null) {
                if (type.prototype.isReactComponent) {
                  // React class.
                  return true;
                }

                var ownNames = Object.getOwnPropertyNames(type.prototype);

                if (ownNames.length > 1 || ownNames[0] !== 'constructor') {
                  // This looks like a class.
                  return false;
                } // eslint-disable-next-line no-proto


                if (type.prototype.__proto__ !== Object.prototype) {
                  // It has a superclass.
                  return false;
                } // Pass through.
                // This looks like a regular function with empty prototype.

              } // For plain functions and arrows, use name as a heuristic.


              var name = type.name || type.displayName;
              return typeof name === 'string' && /^[A-Z]/.test(name);
            }

          case 'object':
            {
              if (type != null) {
                switch (type.$$typeof) {
                  case REACT_FORWARD_REF_TYPE:
                  case REACT_MEMO_TYPE:
                    // Definitely React components.
                    return true;

                  default:
                    return false;
                }
              }

              return false;
            }

          default:
            {
              return false;
            }
        }
      }
    }

    var ReactFreshRuntime = Object.freeze({
      performReactRefresh: performReactRefresh,
      register: register,
      setSignature: setSignature,
      collectCustomHooksForSignature: collectCustomHooksForSignature,
      getFamilyByID: getFamilyByID,
      getFamilyByType: getFamilyByType,
      findAffectedHostInstances: findAffectedHostInstances,
      injectIntoGlobalHook: injectIntoGlobalHook,
      hasUnrecoverableErrors: hasUnrecoverableErrors,
      _getMountedRootCount: _getMountedRootCount,
      createSignatureFunctionForTransform: createSignatureFunctionForTransform,
      isLikelyComponentType: isLikelyComponentType
    }); // This is hacky but makes it work with both Rollup and Jest.

    var runtime = ReactFreshRuntime.default || ReactFreshRuntime;
    module.exports = runtime;
  })();
}
},{}],"9e6c9279921cd7463bde46581d76eda7":[function(require,module,exports) {
var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = 1234;
var HMR_ENV_HASH = "d751713988987e9331980363e24189ce";
module.bundle.HMR_BUNDLE_ID = "783678e28765a6b684b9db16b43588fb";
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH */

var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;

function Module(moduleName) {
  OldModule.call(this, moduleName);
  this.hot = {
    data: module.bundle.hotData,
    _acceptCallbacks: [],
    _disposeCallbacks: [],
    accept: function (fn) {
      this._acceptCallbacks.push(fn || function () {});
    },
    dispose: function (fn) {
      this._disposeCallbacks.push(fn);
    }
  };
  module.bundle.hotData = null;
}

module.bundle.Module = Module;
var checkedAssets, assetsToAccept, acceptedAssets; // eslint-disable-next-line no-redeclare

var parent = module.bundle.parent;

if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
  var hostname = HMR_HOST || (location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');
  var port = HMR_PORT || location.port;
  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';
  var ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/');

  ws.onmessage = function (event) {
    checkedAssets = {};
    assetsToAccept = [];
    acceptedAssets = {};
    var data = JSON.parse(event.data);

    if (data.type === 'update') {
      // Remove error overlay if there is one
      removeErrorOverlay();
      let assets = data.assets.filter(asset => asset.envHash === HMR_ENV_HASH); // Handle HMR Update

      var handled = false;
      assets.forEach(asset => {
        var didAccept = asset.type === 'css' || hmrAcceptCheck(global.parcelRequire, asset.id);

        if (didAccept) {
          handled = true;
        }
      });

      if (handled) {
        console.clear();
        assets.forEach(function (asset) {
          hmrApply(global.parcelRequire, asset);
        });

        for (var i = 0; i < assetsToAccept.length; i++) {
          var id = assetsToAccept[i][1];

          if (!acceptedAssets[id]) {
            hmrAcceptRun(assetsToAccept[i][0], id);
          }
        }
      } else {
        window.location.reload();
      }
    }

    if (data.type === 'error') {
      // Log parcel errors to console
      for (let ansiDiagnostic of data.diagnostics.ansi) {
        let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
        console.error('ðŸš¨ [parcel]: ' + ansiDiagnostic.message + '\n' + stack + '\n\n' + ansiDiagnostic.hints.join('\n'));
      } // Render the fancy html overlay


      removeErrorOverlay();
      var overlay = createErrorOverlay(data.diagnostics.html);
      document.body.appendChild(overlay);
    }
  };

  ws.onerror = function (e) {
    console.error(e.message);
  };

  ws.onclose = function (e) {
    console.warn('[parcel] ðŸš¨ Connection to the HMR server was lost');
  };
}

function removeErrorOverlay() {
  var overlay = document.getElementById(OVERLAY_ID);

  if (overlay) {
    overlay.remove();
    console.log('[parcel] âœ¨ Error resolved');
  }
}

function createErrorOverlay(diagnostics) {
  var overlay = document.createElement('div');
  overlay.id = OVERLAY_ID;
  let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';

  for (let diagnostic of diagnostics) {
    let stack = diagnostic.codeframe ? diagnostic.codeframe : diagnostic.stack;
    errorHTML += `
      <div>
        <div style="font-size: 18px; font-weight: bold; margin-top: 20px;">
          ðŸš¨ ${diagnostic.message}
        </div>
        <pre>
          ${stack}
        </pre>
        <div>
          ${diagnostic.hints.map(hint => '<div>' + hint + '</div>').join('')}
        </div>
      </div>
    `;
  }

  errorHTML += '</div>';
  overlay.innerHTML = errorHTML;
  return overlay;
}

function getParents(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return [];
  }

  var parents = [];
  var k, d, dep;

  for (k in modules) {
    for (d in modules[k][1]) {
      dep = modules[k][1][d];

      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {
        parents.push([bundle, k]);
      }
    }
  }

  if (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }

  return parents;
}

function updateLink(link) {
  var newLink = link.cloneNode();

  newLink.onload = function () {
    if (link.parentNode !== null) {
      link.parentNode.removeChild(link);
    }
  };

  newLink.setAttribute('href', link.getAttribute('href').split('?')[0] + '?' + Date.now());
  link.parentNode.insertBefore(newLink, link.nextSibling);
}

var cssTimeout = null;

function reloadCSS() {
  if (cssTimeout) {
    return;
  }

  cssTimeout = setTimeout(function () {
    var links = document.querySelectorAll('link[rel="stylesheet"]');

    for (var i = 0; i < links.length; i++) {
      var absolute = /^https?:\/\//i.test(links[i].getAttribute('href'));

      if (!absolute) {
        updateLink(links[i]);
      }
    }

    cssTimeout = null;
  }, 50);
}

function hmrApply(bundle, asset) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (modules[asset.id] || !bundle.parent) {
    if (asset.type === 'css') {
      reloadCSS();
    } else {
      var fn = new Function('require', 'module', 'exports', asset.output);
      modules[asset.id] = [fn, asset.depsByBundle[bundle.HMR_BUNDLE_ID]];
    }
  } else if (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}

function hmrAcceptCheck(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (!modules[id] && bundle.parent) {
    return hmrAcceptCheck(bundle.parent, id);
  }

  if (checkedAssets[id]) {
    return;
  }

  checkedAssets[id] = true;
  var cached = bundle.cache[id];
  assetsToAccept.push([bundle, id]);

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    return true;
  }

  return getParents(global.parcelRequire, id).some(function (v) {
    return hmrAcceptCheck(v[0], v[1]);
  });
}

function hmrAcceptRun(bundle, id) {
  var cached = bundle.cache[id];
  bundle.hotData = {};

  if (cached && cached.hot) {
    cached.hot.data = bundle.hotData;
  }

  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(function (cb) {
      cb(bundle.hotData);
    });
  }

  delete bundle.cache[id];
  bundle(id);
  cached = bundle.cache[id];

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(function (cb) {
      var assetsToAlsoAccept = cb(function () {
        return getParents(global.parcelRequire, id);
      });

      if (assetsToAlsoAccept && assetsToAccept.length) {
        assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
      }
    });
  }

  acceptedAssets[id] = true;
}
},{}],"bd665bee0b094abac42ce96c8f8b084d":[function(require,module,exports) {
"use strict";

var _index = require("../main-thread/index");

var channel = new MessageChannel();

channel.port1.onmessage = function (m) {
  return console.log("p1", m);
}; // channel.port2.onmessage = (m)=>console.log("p2", m)


(0, _index.upgradeElement)(document.getElementById('upgrade-me'), 'dist/worker/worker.mjs', channel);
},{"../main-thread/index":"2639ba2ccde03f7d649134cf3bc3e69f"}],"2639ba2ccde03f7d649134cf3bc3e69f":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.upgradeElement = upgradeElement;

var _install = require("./install");

/**
 * Copyright 2018 The AMP HTML Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function upgradeElement(baseElement, domURL, messageChannel) {
  const authorURL = baseElement.getAttribute('src');

  if (authorURL) {
    return (0, _install.fetchAndInstall)(baseElement, {
      messageChannel,
      authorURL,
      domURL
    });
  }

  return Promise.resolve(null);
}
},{"./install":"653e899a548582aa67e3078fa604f4f4"}],"653e899a548582aa67e3078fa604f4f4":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fetchAndInstall = fetchAndInstall;
exports.install = install;

var _Messages = require("../transfer/Messages");

var _mutator = require("./mutator");

var _nodes = require("./nodes");

var _strings = require("./strings");

var _TransferrableKeys = require("../transfer/TransferrableKeys");

var _configuration = require("./configuration");

var _worker = require("./worker");

var _objectContext = require("./object-context");

var _exportedWorker = require("./exported-worker");

/**
 * Copyright 2018 The AMP HTML Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ALLOWABLE_MESSAGE_TYPES = [_Messages.MessageType.MUTATE, _Messages.MessageType.HYDRATE];
/**
 * @param baseElement
 * @param authorScriptURL
 * @param workerDOMURL
 * @param callbacks
 * @param sanitizer
 * @param debug
 */

function fetchAndInstall(baseElement, config) {
  const fetchPromise = Promise.all([// TODO(KB): Fetch Polyfill for IE11.
  fetch(config.domURL).then(response => response.text()), fetch(config.authorURL).then(response => response.text())]);
  return install(fetchPromise, baseElement, config);
}
/**
 * @param fetchPromise
 * @param baseElement
 * @param config
 */


function install(fetchPromise, baseElement, config) {
  const stringContext = new _strings.StringContext();
  const objectContext = new _objectContext.ObjectContext();
  const nodeContext = new _nodes.NodeContext(stringContext, baseElement);
  const normalizedConfig = (0, _configuration.normalizeConfiguration)(config);
  return fetchPromise.then(([domScriptContent, authorScriptContent]) => {
    if (domScriptContent && authorScriptContent && config.authorURL) {
      const workerContext = new _worker.WorkerContext(baseElement, nodeContext, domScriptContent, authorScriptContent, normalizedConfig);
      const mutatorContext = new _mutator.MutatorProcessor(stringContext, nodeContext, workerContext, normalizedConfig, objectContext);

      workerContext.worker.onmessage = message => {
        const {
          data
        } = message;

        if (!ALLOWABLE_MESSAGE_TYPES.includes(data[_TransferrableKeys.TransferrableKeys.type])) {
          return;
        }

        mutatorContext.mutate(data[_TransferrableKeys.TransferrableKeys.phase], data[_TransferrableKeys.TransferrableKeys.nodes], data[_TransferrableKeys.TransferrableKeys.strings], new Uint16Array(data[_TransferrableKeys.TransferrableKeys.mutations]));
      };

      return new _exportedWorker.ExportedWorker(workerContext, normalizedConfig);
    }

    return null;
  });
}
},{"../transfer/Messages":"99507ba4e687c3fb9b635299dae9953c","./mutator":"0a709dc76f254cd42d0c0369a38be11b","./nodes":"64f935a18a4d1c6fb56347b7941f194b","./strings":"9b8dafde2db2a949457a0b7100cb929c","../transfer/TransferrableKeys":"38ecb3927f64cad8acafe7b8b5601eb5","./configuration":"d3372d52f19dda82de1cff2a4e8e1c46","./worker":"65e4ce607d8f5dbfbc362c57dbad5a23","./object-context":"824b44ecae2781d5cd76b62ce5e155e2","./exported-worker":"10f1cd8b14791472d832b6a2e8ae57b6"}],"99507ba4e687c3fb9b635299dae9953c":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ResolveOrReject = exports.GetOrSet = exports.MessageType = void 0;

var _TransferrableKeys = require("./TransferrableKeys");

/**
 * Copyright 2018 The AMP HTML Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let MessageType;
exports.MessageType = MessageType;

(function (MessageType) {
  MessageType[MessageType["EVENT"] = 1] = "EVENT";
  MessageType[MessageType["HYDRATE"] = 2] = "HYDRATE";
  MessageType[MessageType["MUTATE"] = 3] = "MUTATE";
  MessageType[MessageType["SYNC"] = 4] = "SYNC";
  MessageType[MessageType["RESIZE"] = 5] = "RESIZE";
  MessageType[MessageType["GET_BOUNDING_CLIENT_RECT"] = 6] = "GET_BOUNDING_CLIENT_RECT";
  MessageType[MessageType["LONG_TASK_START"] = 7] = "LONG_TASK_START";
  MessageType[MessageType["LONG_TASK_END"] = 8] = "LONG_TASK_END";
  MessageType[MessageType["OFFSCREEN_CANVAS_INSTANCE"] = 9] = "OFFSCREEN_CANVAS_INSTANCE";
  MessageType[MessageType["IMAGE_BITMAP_INSTANCE"] = 10] = "IMAGE_BITMAP_INSTANCE";
  MessageType[MessageType["GET_STORAGE"] = 11] = "GET_STORAGE";
  MessageType[MessageType["FUNCTION"] = 12] = "FUNCTION";
})(MessageType || (exports.MessageType = MessageType = {}));

/**
 * Can parameterize a method invocation message as a getter or setter.
 */
let GetOrSet;
/**
 * Can parameterize a method invocation value as a resolved or rejected.
 */

exports.GetOrSet = GetOrSet;

(function (GetOrSet) {
  GetOrSet[GetOrSet["GET"] = 1] = "GET";
  GetOrSet[GetOrSet["SET"] = 2] = "SET";
})(GetOrSet || (exports.GetOrSet = GetOrSet = {}));

let ResolveOrReject;
exports.ResolveOrReject = ResolveOrReject;

(function (ResolveOrReject) {
  ResolveOrReject[ResolveOrReject["RESOLVE"] = 1] = "RESOLVE";
  ResolveOrReject[ResolveOrReject["REJECT"] = 2] = "REJECT";
})(ResolveOrReject || (exports.ResolveOrReject = ResolveOrReject = {}));
},{"./TransferrableKeys":"38ecb3927f64cad8acafe7b8b5601eb5"}],"38ecb3927f64cad8acafe7b8b5601eb5":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TransferrableKeys = void 0;

/**
 * Copyright 2018 The AMP HTML Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let TransferrableKeys;
exports.TransferrableKeys = TransferrableKeys;

(function (TransferrableKeys) {
  TransferrableKeys[TransferrableKeys["nodeType"] = 0] = "nodeType";
  TransferrableKeys[TransferrableKeys["localOrNodeName"] = 1] = "localOrNodeName";
  TransferrableKeys[TransferrableKeys["attributes"] = 2] = "attributes";
  TransferrableKeys[TransferrableKeys["properties"] = 3] = "properties";
  TransferrableKeys[TransferrableKeys["childNodes"] = 4] = "childNodes";
  TransferrableKeys[TransferrableKeys["textContent"] = 5] = "textContent";
  TransferrableKeys[TransferrableKeys["namespaceURI"] = 6] = "namespaceURI";
  TransferrableKeys[TransferrableKeys["index"] = 7] = "index";
  TransferrableKeys[TransferrableKeys["creationFormat"] = 8] = "creationFormat";
  TransferrableKeys[TransferrableKeys["transferredFormat"] = 9] = "transferredFormat";
  TransferrableKeys[TransferrableKeys["handlers"] = 10] = "handlers";
  TransferrableKeys[TransferrableKeys["transferred"] = 11] = "transferred";
  TransferrableKeys[TransferrableKeys["type"] = 12] = "type";
  TransferrableKeys[TransferrableKeys["target"] = 13] = "target";
  TransferrableKeys[TransferrableKeys["addedNodes"] = 14] = "addedNodes";
  TransferrableKeys[TransferrableKeys["removedNodes"] = 15] = "removedNodes";
  TransferrableKeys[TransferrableKeys["previousSibling"] = 16] = "previousSibling";
  TransferrableKeys[TransferrableKeys["nextSibling"] = 17] = "nextSibling";
  TransferrableKeys[TransferrableKeys["attributeName"] = 18] = "attributeName";
  TransferrableKeys[TransferrableKeys["attributeNamespace"] = 19] = "attributeNamespace";
  TransferrableKeys[TransferrableKeys["propertyName"] = 20] = "propertyName";
  TransferrableKeys[TransferrableKeys["value"] = 21] = "value";
  TransferrableKeys[TransferrableKeys["oldValue"] = 22] = "oldValue";
  TransferrableKeys[TransferrableKeys["addedEvents"] = 23] = "addedEvents";
  TransferrableKeys[TransferrableKeys["removedEvents"] = 24] = "removedEvents";
  TransferrableKeys[TransferrableKeys["bubbles"] = 25] = "bubbles";
  TransferrableKeys[TransferrableKeys["cancelable"] = 26] = "cancelable";
  TransferrableKeys[TransferrableKeys["cancelBubble"] = 27] = "cancelBubble";
  TransferrableKeys[TransferrableKeys["currentTarget"] = 28] = "currentTarget";
  TransferrableKeys[TransferrableKeys["defaultPrevented"] = 29] = "defaultPrevented";
  TransferrableKeys[TransferrableKeys["eventPhase"] = 30] = "eventPhase";
  TransferrableKeys[TransferrableKeys["isTrusted"] = 31] = "isTrusted";
  TransferrableKeys[TransferrableKeys["returnValue"] = 32] = "returnValue";
  TransferrableKeys[TransferrableKeys["timeStamp"] = 33] = "timeStamp";
  TransferrableKeys[TransferrableKeys["scoped"] = 34] = "scoped";
  TransferrableKeys[TransferrableKeys["keyCode"] = 35] = "keyCode";
  TransferrableKeys[TransferrableKeys["mutations"] = 36] = "mutations";
  TransferrableKeys[TransferrableKeys["nodes"] = 37] = "nodes";
  TransferrableKeys[TransferrableKeys["data"] = 38] = "data";
  TransferrableKeys[TransferrableKeys["event"] = 39] = "event";
  TransferrableKeys[TransferrableKeys["sync"] = 40] = "sync";
  TransferrableKeys[TransferrableKeys["strings"] = 41] = "strings";
  TransferrableKeys[TransferrableKeys["records"] = 42] = "records";
  TransferrableKeys[TransferrableKeys["tokens"] = 43] = "tokens";
  TransferrableKeys[TransferrableKeys["storeAttribute"] = 44] = "storeAttribute";
  TransferrableKeys[TransferrableKeys["scopingRoot"] = 45] = "scopingRoot";
  TransferrableKeys[TransferrableKeys["propertyBackedAttributes"] = 46] = "propertyBackedAttributes";
  TransferrableKeys[TransferrableKeys["checked"] = 47] = "checked";
  TransferrableKeys[TransferrableKeys["indeterminate"] = 48] = "indeterminate";
  TransferrableKeys[TransferrableKeys["size"] = 49] = "size";
  TransferrableKeys[TransferrableKeys["stop"] = 50] = "stop";
  TransferrableKeys[TransferrableKeys["end"] = 51] = "end";
  TransferrableKeys[TransferrableKeys["selected"] = 52] = "selected";
  TransferrableKeys[TransferrableKeys["command"] = 53] = "command";
  TransferrableKeys[TransferrableKeys["phase"] = 54] = "phase";
  TransferrableKeys[TransferrableKeys["worker"] = 55] = "worker";
  TransferrableKeys[TransferrableKeys["insertedNode"] = 56] = "insertedNode";
  TransferrableKeys[TransferrableKeys["removedNode"] = 57] = "removedNode";
  TransferrableKeys[TransferrableKeys["allowTransfer"] = 58] = "allowTransfer";
  TransferrableKeys[TransferrableKeys["observe"] = 59] = "observe";
  TransferrableKeys[TransferrableKeys["pageX"] = 60] = "pageX";
  TransferrableKeys[TransferrableKeys["pageY"] = 61] = "pageY";
  TransferrableKeys[TransferrableKeys["touches"] = 62] = "touches";
  TransferrableKeys[TransferrableKeys["changedTouches"] = 63] = "changedTouches";
  TransferrableKeys[TransferrableKeys["hydrateNode"] = 64] = "hydrateNode";
  TransferrableKeys[TransferrableKeys["offsetX"] = 65] = "offsetX";
  TransferrableKeys[TransferrableKeys["offsetY"] = 66] = "offsetY";
  TransferrableKeys[TransferrableKeys["mutated"] = 67] = "mutated";
  TransferrableKeys[TransferrableKeys["serializeAsTransferrableObject"] = 68] = "serializeAsTransferrableObject";
  TransferrableKeys[TransferrableKeys["retrieveCanvasPattern"] = 69] = "retrieveCanvasPattern";
  TransferrableKeys[TransferrableKeys["patternImplementation"] = 70] = "patternImplementation";
  TransferrableKeys[TransferrableKeys["patternUpgraded"] = 71] = "patternUpgraded";
  TransferrableKeys[TransferrableKeys["patternUpgradePromise"] = 72] = "patternUpgradePromise";
  TransferrableKeys[TransferrableKeys["callIndex"] = 73] = "callIndex";
  TransferrableKeys[TransferrableKeys["storageKey"] = 74] = "storageKey";
  TransferrableKeys[TransferrableKeys["storageLocation"] = 75] = "storageLocation";
  TransferrableKeys[TransferrableKeys["propertyEventHandlers"] = 76] = "propertyEventHandlers";
  TransferrableKeys[TransferrableKeys["functionIdentifier"] = 77] = "functionIdentifier";
  TransferrableKeys[TransferrableKeys["functionArguments"] = 78] = "functionArguments";
  TransferrableKeys[TransferrableKeys["END"] = 78] = "END";
})(TransferrableKeys || (exports.TransferrableKeys = TransferrableKeys = {}));
},{}],"0a709dc76f254cd42d0c0369a38be11b":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MutatorProcessor = void 0;

var _offscreenCanvas = require("./commands/offscreen-canvas");

var _TransferrableMutation = require("../transfer/TransferrableMutation");

var _eventSubscription = require("./commands/event-subscription");

var _boundingClientRect = require("./commands/bounding-client-rect");

var _childList = require("./commands/child-list");

var _attribute = require("./commands/attribute");

var _characterData = require("./commands/character-data");

var _property = require("./commands/property");

var _longTask = require("./commands/long-task");

var _objectMutation = require("./commands/object-mutation");

var _objectCreation = require("./commands/object-creation");

var _imageBitmap = require("./commands/image-bitmap");

var _storage = require("./commands/storage");

var _function = require("./commands/function");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class MutatorProcessor {
  /**
   * @param stringContext
   * @param nodeContext
   * @param workerContext
   * @param sanitizer Sanitizer to apply to content if needed.
   */
  constructor(stringContext, nodeContext, workerContext, config, objectContext) {
    _defineProperty(this, "mutationQueue", []);

    _defineProperty(this, "pendingMutations", false);

    _defineProperty(this, "syncFlush", (allowVisibleMutations = true) => {
      if (undefined) {
        console.group('Mutations');
      }

      const disallowedMutations = [];
      this.mutationQueue.forEach(mutationArray => {
        const length = mutationArray.length;
        let operationStart = 0;

        while (operationStart < length) {
          // TransferrableMutationType is always at position 0.
          const mutationType = mutationArray[operationStart]; // TODO(worker-dom): Hoist `allow` up to entry point (index.amp.ts) to avoid bundling `isUserVisibleMutation`.

          const allow = allowVisibleMutations || !(0, _TransferrableMutation.isUserVisibleMutation)(mutationType);

          if (!allow) {
            // TODO(worker-dom): Consider returning the strings from executor.print() for better error messaging.
            disallowedMutations.push(mutationType);
          }

          const executor = this.executors[mutationType];

          if (undefined) {
            console.log(allow ? '' : '[disallowed]', _TransferrableMutation.ReadableMutationType[mutationType], executor.print(mutationArray, operationStart));
          }

          operationStart = executor.execute(mutationArray, operationStart, allow);
        }
      });

      if (undefined) {
        console.groupEnd();
      }

      this.mutationQueue = [];
      this.pendingMutations = false;
      return disallowedMutations;
    });

    this.stringContext = stringContext;
    this.nodeContext = nodeContext;
    this.sanitizer = config.sanitizer;
    this.mutationPumpFunction = config.mutationPump;
    const args = [stringContext, nodeContext, workerContext, objectContext, config];

    const sharedLongTaskProcessor = _longTask.LongTaskExecutor.apply(null, args);

    this.executors = {
      [_TransferrableMutation.TransferrableMutationType.CHILD_LIST]: _childList.ChildListProcessor.apply(null, args),
      [_TransferrableMutation.TransferrableMutationType.ATTRIBUTES]: _attribute.AttributeProcessor.apply(null, args),
      [_TransferrableMutation.TransferrableMutationType.CHARACTER_DATA]: _characterData.CharacterDataProcessor.apply(null, args),
      [_TransferrableMutation.TransferrableMutationType.PROPERTIES]: _property.PropertyProcessor.apply(null, args),
      [_TransferrableMutation.TransferrableMutationType.EVENT_SUBSCRIPTION]: _eventSubscription.EventSubscriptionProcessor.apply(null, args),
      [_TransferrableMutation.TransferrableMutationType.GET_BOUNDING_CLIENT_RECT]: _boundingClientRect.BoundingClientRectProcessor.apply(null, args),
      [_TransferrableMutation.TransferrableMutationType.LONG_TASK_START]: sharedLongTaskProcessor,
      [_TransferrableMutation.TransferrableMutationType.LONG_TASK_END]: sharedLongTaskProcessor,
      [_TransferrableMutation.TransferrableMutationType.OFFSCREEN_CANVAS_INSTANCE]: _offscreenCanvas.OffscreenCanvasProcessor.apply(null, args),
      [_TransferrableMutation.TransferrableMutationType.OBJECT_MUTATION]: _objectMutation.ObjectMutationProcessor.apply(null, args),
      [_TransferrableMutation.TransferrableMutationType.OBJECT_CREATION]: _objectCreation.ObjectCreationProcessor.apply(null, args),
      [_TransferrableMutation.TransferrableMutationType.IMAGE_BITMAP_INSTANCE]: _imageBitmap.ImageBitmapProcessor.apply(null, args),
      [_TransferrableMutation.TransferrableMutationType.STORAGE]: _storage.StorageProcessor.apply(null, args),
      [_TransferrableMutation.TransferrableMutationType.FUNCTION_CALL]: _function.FunctionProcessor.apply(null, args)
    };
  }
  /**
   * Process MutationRecords from worker thread applying changes to the existing DOM.
   * @param phase Current Phase Worker Thread exists in.
   * @param nodes New nodes to add in the main thread with the incoming mutations.
   * @param stringValues Additional string values to use in decoding messages.
   * @param mutations Changes to apply in both graph shape and content of Elements.
   */


  mutate(phase, nodes, stringValues, mutations) {
    this.stringContext.storeValues(stringValues);
    this.nodeContext.createNodes(nodes, this.sanitizer);
    this.mutationQueue = this.mutationQueue.concat(mutations);

    if (!this.pendingMutations) {
      this.pendingMutations = true;
      this.mutationPumpFunction(this.syncFlush, phase);
    }
  }
  /**
   * Apply all stored mutations syncronously. This method works well, but can cause jank if there are too many
   * mutations to apply in a single frame.
   *
   * Investigations in using asyncFlush to resolve are worth considering.
   *
   * @param allowVisibleMutations
   * @return Array of mutation types that were disallowed.
   */


}

exports.MutatorProcessor = MutatorProcessor;
},{"./commands/offscreen-canvas":"e1a9c0ef5a563da23c59ab87eb192fb7","../transfer/TransferrableMutation":"d13bf1ec6ccac463f51d13cf5711f92b","./commands/event-subscription":"d5f875a605c8e7c7352a153b4110f36e","./commands/bounding-client-rect":"c81681b06bf35c68ff927a26fe3a78c6","./commands/child-list":"92b936715fd22b6d1de0be422ee67e26","./commands/attribute":"6988f77df2ebeac26e7a287ebe414754","./commands/character-data":"49fdf912bdc8ded6204712ec5580b042","./commands/property":"74dd53a753e8b7eabf5f43632bc09feb","./commands/long-task":"87ee9f055fac46fbdeff97c473204064","./commands/object-mutation":"3a760954c58805bac97f0afd5021917b","./commands/object-creation":"ba827ede0e5e4a3cc92dd40c41a947be","./commands/image-bitmap":"2d11db9497d2247c150bddb26396c8ca","./commands/storage":"20457afb7535d84044adb402cad2ec00","./commands/function":"da8cdd19aabb35c9fec1b151586a109a"}],"e1a9c0ef5a563da23c59ab87eb192fb7":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.OffscreenCanvasProcessor = void 0;

var _TransferrableKeys = require("../../transfer/TransferrableKeys");

var _Messages = require("../../transfer/Messages");

var _TransferrableMutation = require("../../transfer/TransferrableMutation");

/**
 * Copyright 2019 The AMP HTML Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const OffscreenCanvasProcessor = (strings, nodeContext, workerContext, objectContext, config) => {
  const allowedExecution = config.executorsAllowed.includes(_TransferrableMutation.TransferrableMutationType.OFFSCREEN_CANVAS_INSTANCE);
  return {
    execute(mutations, startPosition, allowedMutation) {
      if (allowedExecution && allowedMutation) {
        const targetIndex = mutations[startPosition + _TransferrableMutation.OffscreenCanvasMutationIndex.Target];
        const target = nodeContext.getNode(targetIndex);

        if (target) {
          const offscreen = target.transferControlToOffscreen();
          workerContext.messageToWorker({
            [_TransferrableKeys.TransferrableKeys.type]: _Messages.MessageType.OFFSCREEN_CANVAS_INSTANCE,
            [_TransferrableKeys.TransferrableKeys.target]: [target._index_],
            [_TransferrableKeys.TransferrableKeys.data]: offscreen // Object, an OffscreenCanvas

          }, [offscreen]);
        } else {
          console.error(`'OFFSCREEN_CANVAS_INSTANCE': getNode(${targetIndex}) is null.`);
        }
      }

      return startPosition + _TransferrableMutation.OffscreenCanvasMutationIndex.End;
    },

    print(mutations, startPosition, target) {
      return {
        type: 'OFFSCREEN_CANVAS_INSTANCE',
        target,
        allowedExecution
      };
    }

  };
};

exports.OffscreenCanvasProcessor = OffscreenCanvasProcessor;
},{"../../transfer/TransferrableKeys":"38ecb3927f64cad8acafe7b8b5601eb5","../../transfer/Messages":"99507ba4e687c3fb9b635299dae9953c","../../transfer/TransferrableMutation":"d13bf1ec6ccac463f51d13cf5711f92b"}],"d13bf1ec6ccac463f51d13cf5711f92b":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FunctionMutationIndex = exports.StorageMutationIndex = exports.TransferrableObjectType = exports.ObjectCreationIndex = exports.ObjectMutationIndex = exports.ImageBitmapMutationIndex = exports.OffscreenCanvasMutationIndex = exports.LongTaskMutationIndex = exports.PropertyMutationIndex = exports.CharacterDataMutationIndex = exports.AttributeMutationIndex = exports.ChildListMutationIndex = exports.ReadableMutationType = exports.DefaultAllowedMutations = exports.isUserVisibleMutation = exports.TransferrableMutationType = void 0;

/**
 * Copyright 2019 The AMP HTML Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let TransferrableMutationType;
/**
 * Returns true if the mutation type can cause a user-visible change to the DOM.
 * @param type
 */

exports.TransferrableMutationType = TransferrableMutationType;

(function (TransferrableMutationType) {
  TransferrableMutationType[TransferrableMutationType["ATTRIBUTES"] = 0] = "ATTRIBUTES";
  TransferrableMutationType[TransferrableMutationType["CHARACTER_DATA"] = 1] = "CHARACTER_DATA";
  TransferrableMutationType[TransferrableMutationType["CHILD_LIST"] = 2] = "CHILD_LIST";
  TransferrableMutationType[TransferrableMutationType["PROPERTIES"] = 3] = "PROPERTIES";
  TransferrableMutationType[TransferrableMutationType["EVENT_SUBSCRIPTION"] = 4] = "EVENT_SUBSCRIPTION";
  TransferrableMutationType[TransferrableMutationType["GET_BOUNDING_CLIENT_RECT"] = 5] = "GET_BOUNDING_CLIENT_RECT";
  TransferrableMutationType[TransferrableMutationType["LONG_TASK_START"] = 6] = "LONG_TASK_START";
  TransferrableMutationType[TransferrableMutationType["LONG_TASK_END"] = 7] = "LONG_TASK_END";
  TransferrableMutationType[TransferrableMutationType["OFFSCREEN_CANVAS_INSTANCE"] = 8] = "OFFSCREEN_CANVAS_INSTANCE";
  TransferrableMutationType[TransferrableMutationType["OBJECT_MUTATION"] = 9] = "OBJECT_MUTATION";
  TransferrableMutationType[TransferrableMutationType["OBJECT_CREATION"] = 10] = "OBJECT_CREATION";
  TransferrableMutationType[TransferrableMutationType["IMAGE_BITMAP_INSTANCE"] = 11] = "IMAGE_BITMAP_INSTANCE";
  TransferrableMutationType[TransferrableMutationType["STORAGE"] = 12] = "STORAGE";
  TransferrableMutationType[TransferrableMutationType["FUNCTION_CALL"] = 13] = "FUNCTION_CALL";
})(TransferrableMutationType || (exports.TransferrableMutationType = TransferrableMutationType = {}));

const isUserVisibleMutation = type => {
  switch (type) {
    case TransferrableMutationType.EVENT_SUBSCRIPTION:
    case TransferrableMutationType.GET_BOUNDING_CLIENT_RECT:
    case TransferrableMutationType.LONG_TASK_START:
    case TransferrableMutationType.LONG_TASK_END:
    case TransferrableMutationType.STORAGE:
    case TransferrableMutationType.OFFSCREEN_CANVAS_INSTANCE:
    case TransferrableMutationType.FUNCTION_CALL:
      return false;

    default:
      return true;
  }
};

exports.isUserVisibleMutation = isUserVisibleMutation;
const DefaultAllowedMutations = [TransferrableMutationType.ATTRIBUTES, TransferrableMutationType.CHARACTER_DATA, TransferrableMutationType.CHILD_LIST, TransferrableMutationType.PROPERTIES, TransferrableMutationType.EVENT_SUBSCRIPTION, TransferrableMutationType.GET_BOUNDING_CLIENT_RECT, TransferrableMutationType.LONG_TASK_START, TransferrableMutationType.LONG_TASK_END, TransferrableMutationType.OFFSCREEN_CANVAS_INSTANCE, TransferrableMutationType.OBJECT_MUTATION, TransferrableMutationType.OBJECT_CREATION, TransferrableMutationType.IMAGE_BITMAP_INSTANCE, TransferrableMutationType.STORAGE, TransferrableMutationType.FUNCTION_CALL];
exports.DefaultAllowedMutations = DefaultAllowedMutations;
const ReadableMutationType = {
  0: 'ATTRIBUTES',
  1: 'CHARACTER_DATA',
  2: 'CHILD_LIST',
  3: 'PROPERTIES',
  4: 'EVENT_SUBSCRIPTION',
  5: 'GET_BOUNDING_CLIENT_RECT',
  6: 'LONG_TASK_START',
  7: 'LONG_TASK_END',
  8: 'OFFSCREEN_CANVAS_INSTANCE',
  9: 'OBJECT_MUTATION',
  10: 'OBJECT_CREATION',
  11: 'IMAGE_BITMAP_INSTANCE',
  12: 'STORAGE',
  13: 'FUNCTION_INVOCATION'
};
/**
 * Child List Mutations
 * [
 *   TransferrableMutationType.CHILD_LIST,
 *   Target.index,
 *   NextSibling.index,
 *   PreviousSibling.index,
 *   AppendedNodeCount,
 *   RemovedNodeCount,
 *   ... AppendedNode.index,
 *   ... RemovedNode.index,
 * ]
 */

exports.ReadableMutationType = ReadableMutationType;
let ChildListMutationIndex;
/**
 * Attribute Mutations
 * [
 *   TransferrableMutationType.ATTRIBUTES,
 *   Target.index,
 *   Attr.name,
 *   Attr.namespace,   // 0 is the default value.
 *   Attr.value,       // 0 is the default value.
 * ]
 */

exports.ChildListMutationIndex = ChildListMutationIndex;

(function (ChildListMutationIndex) {
  ChildListMutationIndex[ChildListMutationIndex["Target"] = 1] = "Target";
  ChildListMutationIndex[ChildListMutationIndex["NextSibling"] = 2] = "NextSibling";
  ChildListMutationIndex[ChildListMutationIndex["PreviousSibling"] = 3] = "PreviousSibling";
  ChildListMutationIndex[ChildListMutationIndex["AppendedNodeCount"] = 4] = "AppendedNodeCount";
  ChildListMutationIndex[ChildListMutationIndex["RemovedNodeCount"] = 5] = "RemovedNodeCount";
  ChildListMutationIndex[ChildListMutationIndex["Nodes"] = 6] = "Nodes";
  ChildListMutationIndex[ChildListMutationIndex["End"] = 6] = "End";
})(ChildListMutationIndex || (exports.ChildListMutationIndex = ChildListMutationIndex = {}));

let AttributeMutationIndex;
/**
 * Character Data Mutations
 * [
 *   TransferrableMutationType.CHARACTER_DATA,
 *   Target.index,
 *   CharacterData.value,
 * ]
 */

exports.AttributeMutationIndex = AttributeMutationIndex;

(function (AttributeMutationIndex) {
  AttributeMutationIndex[AttributeMutationIndex["Target"] = 1] = "Target";
  AttributeMutationIndex[AttributeMutationIndex["Name"] = 2] = "Name";
  AttributeMutationIndex[AttributeMutationIndex["Namespace"] = 3] = "Namespace";
  AttributeMutationIndex[AttributeMutationIndex["Value"] = 4] = "Value";
  AttributeMutationIndex[AttributeMutationIndex["End"] = 5] = "End";
})(AttributeMutationIndex || (exports.AttributeMutationIndex = AttributeMutationIndex = {}));

let CharacterDataMutationIndex;
/**
 * Properties Mutations
 * [
 *   TransferrableMutationType.PROPERTIES,
 *   Target.index,
 *   Property.name,
 *   typeof Property.value === boolean,
 *   Property.value,
 * ]
 */

exports.CharacterDataMutationIndex = CharacterDataMutationIndex;

(function (CharacterDataMutationIndex) {
  CharacterDataMutationIndex[CharacterDataMutationIndex["Target"] = 1] = "Target";
  CharacterDataMutationIndex[CharacterDataMutationIndex["Value"] = 2] = "Value";
  CharacterDataMutationIndex[CharacterDataMutationIndex["End"] = 3] = "End";
})(CharacterDataMutationIndex || (exports.CharacterDataMutationIndex = CharacterDataMutationIndex = {}));

let PropertyMutationIndex;
/**
 * Long Task Mutations
 * [
 *   TransferrableMutationType.LONG_TASK_START || TransferrableMutation.LONG_TASK_END
 *   Target.index,
 * ]
 */

exports.PropertyMutationIndex = PropertyMutationIndex;

(function (PropertyMutationIndex) {
  PropertyMutationIndex[PropertyMutationIndex["Target"] = 1] = "Target";
  PropertyMutationIndex[PropertyMutationIndex["Name"] = 2] = "Name";
  PropertyMutationIndex[PropertyMutationIndex["IsBoolean"] = 3] = "IsBoolean";
  PropertyMutationIndex[PropertyMutationIndex["Value"] = 4] = "Value";
  PropertyMutationIndex[PropertyMutationIndex["End"] = 5] = "End";
})(PropertyMutationIndex || (exports.PropertyMutationIndex = PropertyMutationIndex = {}));

let LongTaskMutationIndex;
/**
 * OffscreenCanvas Mutations
 * [
 *   TransferrableMutationType.OFFSCREEN_CANVAS_INSTANCE,
 *   Target.index,
 * ]
 */

exports.LongTaskMutationIndex = LongTaskMutationIndex;

(function (LongTaskMutationIndex) {
  LongTaskMutationIndex[LongTaskMutationIndex["Target"] = 1] = "Target";
  LongTaskMutationIndex[LongTaskMutationIndex["End"] = 2] = "End";
})(LongTaskMutationIndex || (exports.LongTaskMutationIndex = LongTaskMutationIndex = {}));

let OffscreenCanvasMutationIndex;
/**
 * ImageBitmap Mutations
 * [
 *   TransferrableMutationType.IMAGE_BITMAP_INSTANCE,
 *   Target.index,
 * ]
 */

exports.OffscreenCanvasMutationIndex = OffscreenCanvasMutationIndex;

(function (OffscreenCanvasMutationIndex) {
  OffscreenCanvasMutationIndex[OffscreenCanvasMutationIndex["Target"] = 1] = "Target";
  OffscreenCanvasMutationIndex[OffscreenCanvasMutationIndex["End"] = 2] = "End";
})(OffscreenCanvasMutationIndex || (exports.OffscreenCanvasMutationIndex = OffscreenCanvasMutationIndex = {}));

let ImageBitmapMutationIndex;
/**
 * ObjectMutation Mutations
 * [
 *   TransferrableMutationType.IMAGE_BITMAP_INSTANCE,
 *   Target.index,
 * ]
 * // TODO(choumx): Fix naming inconsistency.
 */

exports.ImageBitmapMutationIndex = ImageBitmapMutationIndex;

(function (ImageBitmapMutationIndex) {
  ImageBitmapMutationIndex[ImageBitmapMutationIndex["Target"] = 1] = "Target";
  ImageBitmapMutationIndex[ImageBitmapMutationIndex["CallIndex"] = 2] = "CallIndex";
  ImageBitmapMutationIndex[ImageBitmapMutationIndex["End"] = 3] = "End";
})(ImageBitmapMutationIndex || (exports.ImageBitmapMutationIndex = ImageBitmapMutationIndex = {}));

let ObjectMutationIndex;
exports.ObjectMutationIndex = ObjectMutationIndex;

(function (ObjectMutationIndex) {
  ObjectMutationIndex[ObjectMutationIndex["FunctionName"] = 1] = "FunctionName";
  ObjectMutationIndex[ObjectMutationIndex["ArgumentCount"] = 2] = "ArgumentCount";
  ObjectMutationIndex[ObjectMutationIndex["SerializedTarget"] = 3] = "SerializedTarget";
})(ObjectMutationIndex || (exports.ObjectMutationIndex = ObjectMutationIndex = {}));

/**
 * ObjectCreation Mutations
 * [
 *   TransferrableMutationType.IMAGE_BITMAP_INSTANCE,
 *   Target.index,
 * ]
 * // TODO(choumx): Fix naming inconsistency.
 */
let ObjectCreationIndex;
exports.ObjectCreationIndex = ObjectCreationIndex;

(function (ObjectCreationIndex) {
  ObjectCreationIndex[ObjectCreationIndex["FunctionName"] = 1] = "FunctionName";
  ObjectCreationIndex[ObjectCreationIndex["ObjectId"] = 2] = "ObjectId";
  ObjectCreationIndex[ObjectCreationIndex["ArgumentCount"] = 3] = "ArgumentCount";
  ObjectCreationIndex[ObjectCreationIndex["SerializedTarget"] = 4] = "SerializedTarget";
})(ObjectCreationIndex || (exports.ObjectCreationIndex = ObjectCreationIndex = {}));

/**
 * Used in OBJECT_MUTATION and OBJECT_CREATION mutations for typing non-primitives
 * passed in function parameters, e.g. <image> in CanvasRenderingContext2D.drawImage(<image>).
 */
let TransferrableObjectType;
/**
 * Storage Mutations
 * [
 *   TransferrableMutationType.STORAGE,
 *   GetOrSet,
 *   StorageLocation,
 *   string(key),
 *   string(value),
 * ]
 */

exports.TransferrableObjectType = TransferrableObjectType;

(function (TransferrableObjectType) {
  TransferrableObjectType[TransferrableObjectType["SmallInt"] = 1] = "SmallInt";
  TransferrableObjectType[TransferrableObjectType["Float"] = 2] = "Float";
  TransferrableObjectType[TransferrableObjectType["String"] = 3] = "String";
  TransferrableObjectType[TransferrableObjectType["Array"] = 4] = "Array";
  TransferrableObjectType[TransferrableObjectType["TransferObject"] = 5] = "TransferObject";
  TransferrableObjectType[TransferrableObjectType["CanvasRenderingContext2D"] = 6] = "CanvasRenderingContext2D";
  TransferrableObjectType[TransferrableObjectType["HTMLElement"] = 7] = "HTMLElement";
})(TransferrableObjectType || (exports.TransferrableObjectType = TransferrableObjectType = {}));

let StorageMutationIndex;
/**
 * [
 *   TransferrableMutationType.FunctionInvocation,
 *   ResolveOrReject,
 *   index,
 *   string(value)
 * ]
 */

exports.StorageMutationIndex = StorageMutationIndex;

(function (StorageMutationIndex) {
  StorageMutationIndex[StorageMutationIndex["Operation"] = 1] = "Operation";
  StorageMutationIndex[StorageMutationIndex["Location"] = 2] = "Location";
  StorageMutationIndex[StorageMutationIndex["Key"] = 3] = "Key";
  StorageMutationIndex[StorageMutationIndex["Value"] = 4] = "Value";
  StorageMutationIndex[StorageMutationIndex["End"] = 5] = "End";
})(StorageMutationIndex || (exports.StorageMutationIndex = StorageMutationIndex = {}));

let FunctionMutationIndex;
exports.FunctionMutationIndex = FunctionMutationIndex;

(function (FunctionMutationIndex) {
  FunctionMutationIndex[FunctionMutationIndex["Status"] = 1] = "Status";
  FunctionMutationIndex[FunctionMutationIndex["Index"] = 2] = "Index";
  FunctionMutationIndex[FunctionMutationIndex["Value"] = 3] = "Value";
  FunctionMutationIndex[FunctionMutationIndex["End"] = 4] = "End";
})(FunctionMutationIndex || (exports.FunctionMutationIndex = FunctionMutationIndex = {}));
},{}],"d5f875a605c8e7c7352a153b4110f36e":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EventSubscriptionProcessor = exports.sendValueChangeOnAttributeMutation = exports.applyDefaultInputListener = void 0;

var _Messages = require("../../transfer/Messages");

var _TransferrableKeys = require("../../transfer/TransferrableKeys");

var _TransferrableEvent = require("../../transfer/TransferrableEvent");

var _TransferrableMutation = require("../../transfer/TransferrableMutation");

var _nodes = require("../nodes");

/**
 * Copyright 2018 The AMP HTML Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Monitoring Nodes attribute changes requires a Mutation Observer.
 * We store the nodes being monitored to avoid creating more than one Observer
 * per Element.
 */
const monitoredNodes = new Map();
/**
 * Instead of a whitelist of elements that need their value tracked, use the existence
 * of a property called value to drive the decision.
 * @param node node to check if values should be tracked.
 * @return boolean if the node should have its value property tracked.
 */

const shouldTrackChanges = node => node && 'value' in node;
/**
 * When a node that has a value needing synced doesn't already have an event listener
 * listening for input values, ensure the value is synced with a default listener.
 * @param worker whom to dispatch value toward.
 * @param node node to listen to value changes on.
 */


const applyDefaultInputListener = (workerContext, node) => {
  if (shouldTrackChanges(node) && node.oninput === null) {
    node.oninput = () => fireValueChange(workerContext, node);
  }
};
/**
 * Use a MutationObserver to capture value changes based on Attribute modification (frequently used by frameworks).
 * @param worker whom to dispatch value toward.
 * @param node node to listen to value changes on.
 */


exports.applyDefaultInputListener = applyDefaultInputListener;

const sendValueChangeOnAttributeMutation = (workerContext, node) => {
  if (shouldTrackChanges(node) && !monitoredNodes.get(node)) {
    new MutationObserver(mutations => mutations.map(mutation => fireValueChange(workerContext, mutation.target))).observe(node, {
      attributes: true
    });
    monitoredNodes.set(node, true);
  }
};
/**
 * Tell WorkerDOM what the value is for a Node.
 * @param worker whom to dispatch value toward.
 * @param node where to get the value from.
 */


exports.sendValueChangeOnAttributeMutation = sendValueChangeOnAttributeMutation;

const fireValueChange = (workerContext, node) => workerContext.messageToWorker({
  [_TransferrableKeys.TransferrableKeys.type]: _Messages.MessageType.SYNC,
  [_TransferrableKeys.TransferrableKeys.sync]: {
    [_TransferrableKeys.TransferrableKeys.index]: node._index_,
    [_TransferrableKeys.TransferrableKeys.value]: node.value
  }
});
/**
 * Tell WorkerDOM what the window dimensions are.
 * @param workerContext
 * @param cachedWindowSize
 */


const fireResizeChange = (workerContext, cachedWindowSize) => workerContext.messageToWorker({
  [_TransferrableKeys.TransferrableKeys.type]: _Messages.MessageType.RESIZE,
  [_TransferrableKeys.TransferrableKeys.sync]: cachedWindowSize
});
/**
 * Convert a TouchList into a TransferrableTouchList
 * @param touchList
 */


const createTransferrableTouchList = touchList => Object.values(touchList).map(touch => [touch.identifier, touch.screenX, touch.screenY, touch.clientX, touch.clientY, touch.pageX, touch.pageY, touch.target._index_]);

const EventSubscriptionProcessor = (strings, nodeContext, workerContext, objectContext, config) => {
  const knownListeners = [];
  const allowedExecution = config.executorsAllowed.includes(_TransferrableMutation.TransferrableMutationType.EVENT_SUBSCRIPTION);
  let cachedWindowSize = [window.innerWidth, window.innerHeight];
  /**
   * Register an event handler for dispatching events to worker thread
   * @param worker whom to dispatch events toward
   * @param index node index the event comes from (used to dispatchEvent in worker thread).
   * @return eventHandler function consuming event and dispatching to worker thread
   */

  const eventHandler = (index, preventDefault) => event => {
    if (preventDefault) {
      event.preventDefault();
    }

    if (shouldTrackChanges(event.currentTarget)) {
      fireValueChange(workerContext, event.currentTarget);
    } else if (event.type === 'resize') {
      const {
        innerWidth,
        innerHeight
      } = window;

      if (cachedWindowSize[0] === innerWidth && cachedWindowSize[1] === innerHeight) {
        return;
      }

      cachedWindowSize = [window.innerWidth, window.innerHeight];
      fireResizeChange(workerContext, cachedWindowSize);
    }

    workerContext.messageToWorker({
      [_TransferrableKeys.TransferrableKeys.type]: _Messages.MessageType.EVENT,
      [_TransferrableKeys.TransferrableKeys.event]: {
        [_TransferrableKeys.TransferrableKeys.index]: index,
        [_TransferrableKeys.TransferrableKeys.bubbles]: event.bubbles,
        [_TransferrableKeys.TransferrableKeys.cancelable]: event.cancelable,
        [_TransferrableKeys.TransferrableKeys.cancelBubble]: event.cancelBubble,
        [_TransferrableKeys.TransferrableKeys.currentTarget]: [event.currentTarget._index_ || 0],
        [_TransferrableKeys.TransferrableKeys.defaultPrevented]: event.defaultPrevented,
        [_TransferrableKeys.TransferrableKeys.eventPhase]: event.eventPhase,
        [_TransferrableKeys.TransferrableKeys.isTrusted]: event.isTrusted,
        [_TransferrableKeys.TransferrableKeys.returnValue]: event.returnValue,
        [_TransferrableKeys.TransferrableKeys.target]: [event.target._index_ || 0],
        [_TransferrableKeys.TransferrableKeys.timeStamp]: event.timeStamp,
        [_TransferrableKeys.TransferrableKeys.type]: event.type,
        [_TransferrableKeys.TransferrableKeys.keyCode]: 'keyCode' in event ? event.keyCode : undefined,
        [_TransferrableKeys.TransferrableKeys.pageX]: 'pageX' in event ? event.pageX : undefined,
        [_TransferrableKeys.TransferrableKeys.pageY]: 'pageY' in event ? event.pageY : undefined,
        [_TransferrableKeys.TransferrableKeys.offsetX]: 'offsetX' in event ? event.offsetX : undefined,
        [_TransferrableKeys.TransferrableKeys.offsetY]: 'offsetY' in event ? event.offsetY : undefined,
        [_TransferrableKeys.TransferrableKeys.touches]: 'touches' in event ? createTransferrableTouchList(event.touches) : undefined,
        [_TransferrableKeys.TransferrableKeys.changedTouches]: 'changedTouches' in event ? createTransferrableTouchList(event.changedTouches) : undefined
      }
    });
  };
  /**
   * If the worker requests to add an event listener to 'change' for something the foreground thread is already listening to,
   * ensure that only a single 'change' event is attached to prevent sending values multiple times.
   * @param target node to change listeners on
   * @param addEvent is this an 'addEvent' or 'removeEvent' change
   * @param mutations Uint16Array for this set of changes
   * @param iterator current location in array to perform this change on
   */


  const processListenerChange = (target, addEvent, mutations, iterator) => {
    const type = strings.get(mutations[iterator]);
    const eventIndex = mutations[iterator + _TransferrableEvent.AddEventRegistrationIndex.Index];

    if (target === nodeContext.baseElement) {
      if (addEvent) {
        const preventDefault = Boolean(mutations[iterator + _TransferrableEvent.AddEventRegistrationIndex.WorkerDOMPreventDefault]);
        addEventListener(type, knownListeners[eventIndex] = eventHandler(_nodes.BASE_ELEMENT_INDEX, preventDefault));
      } else {
        removeEventListener(type, knownListeners[eventIndex]);
      }

      return;
    }

    let inputEventSubscribed = target.oninput !== null;
    const isChangeEvent = type === 'change';

    if (addEvent) {
      if (isChangeEvent) {
        inputEventSubscribed = true;
        target.onchange = null;
      }

      const preventDefault = Boolean(mutations[iterator + _TransferrableEvent.AddEventRegistrationIndex.WorkerDOMPreventDefault]);
      target.addEventListener(type, knownListeners[eventIndex] = eventHandler(target._index_, preventDefault));
    } else {
      if (isChangeEvent) {
        inputEventSubscribed = false;
      }

      target.removeEventListener(type, knownListeners[eventIndex]);
    }

    if (shouldTrackChanges(target)) {
      if (!inputEventSubscribed) applyDefaultInputListener(workerContext, target);
      sendValueChangeOnAttributeMutation(workerContext, target);
    }
  };

  return {
    execute(mutations, startPosition, allowedMutation) {
      const addEventListenerCount = mutations[startPosition + _TransferrableEvent.EventSubscriptionMutationIndex.AddEventListenerCount];
      const removeEventListenerCount = mutations[startPosition + _TransferrableEvent.EventSubscriptionMutationIndex.RemoveEventListenerCount];
      const addEventListenersPosition = startPosition + _TransferrableEvent.EventSubscriptionMutationIndex.Events + removeEventListenerCount * _TransferrableEvent.REMOVE_EVENT_SUBSCRIPTION_LENGTH;
      const endPosition = startPosition + _TransferrableEvent.EventSubscriptionMutationIndex.Events + addEventListenerCount * _TransferrableEvent.ADD_EVENT_SUBSCRIPTION_LENGTH + removeEventListenerCount * _TransferrableEvent.REMOVE_EVENT_SUBSCRIPTION_LENGTH;

      if (allowedExecution && allowedMutation) {
        const targetIndex = mutations[startPosition + _TransferrableEvent.EventSubscriptionMutationIndex.Target];
        const target = nodeContext.getNode(targetIndex);

        if (target) {
          let iterator = startPosition + _TransferrableEvent.EventSubscriptionMutationIndex.Events;

          while (iterator < endPosition) {
            const isRemoveEvent = iterator <= addEventListenersPosition;
            processListenerChange(target, isRemoveEvent, mutations, iterator);
            iterator += isRemoveEvent ? _TransferrableEvent.REMOVE_EVENT_SUBSCRIPTION_LENGTH : _TransferrableEvent.ADD_EVENT_SUBSCRIPTION_LENGTH;
          }
        } else {
          console.error(`getNode(${targetIndex}) is null.`);
        }
      }

      return endPosition;
    },

    print(mutations, startPosition) {
      const addEventListenerCount = mutations[startPosition + _TransferrableEvent.EventSubscriptionMutationIndex.AddEventListenerCount];
      const removeEventListenerCount = mutations[startPosition + _TransferrableEvent.EventSubscriptionMutationIndex.RemoveEventListenerCount];
      const addEventListenersPosition = startPosition + _TransferrableEvent.EventSubscriptionMutationIndex.Events + removeEventListenerCount * _TransferrableEvent.REMOVE_EVENT_SUBSCRIPTION_LENGTH;
      const endPosition = startPosition + _TransferrableEvent.EventSubscriptionMutationIndex.Events + addEventListenerCount * _TransferrableEvent.ADD_EVENT_SUBSCRIPTION_LENGTH + removeEventListenerCount * _TransferrableEvent.REMOVE_EVENT_SUBSCRIPTION_LENGTH;
      const targetIndex = mutations[startPosition + _TransferrableEvent.EventSubscriptionMutationIndex.Target];
      const target = nodeContext.getNode(targetIndex);
      const removedEventListeners = [];
      const addedEventListeners = [];
      let iterator = startPosition + _TransferrableEvent.EventSubscriptionMutationIndex.Events;

      while (iterator < endPosition) {
        const isRemoveEvent = iterator <= addEventListenersPosition;
        const eventList = isRemoveEvent ? addedEventListeners : removedEventListeners;
        eventList.push({
          type: strings.get(mutations[iterator]),
          index: mutations[iterator + 1]
        });
        iterator += isRemoveEvent ? _TransferrableEvent.REMOVE_EVENT_SUBSCRIPTION_LENGTH : _TransferrableEvent.ADD_EVENT_SUBSCRIPTION_LENGTH;
      }

      return {
        target,
        allowedExecution,
        removedEventListeners,
        addedEventListeners
      };
    }

  };
};

exports.EventSubscriptionProcessor = EventSubscriptionProcessor;
},{"../../transfer/Messages":"99507ba4e687c3fb9b635299dae9953c","../../transfer/TransferrableKeys":"38ecb3927f64cad8acafe7b8b5601eb5","../../transfer/TransferrableEvent":"9ea7046b75fd0d302632d8d5a6ed861b","../../transfer/TransferrableMutation":"d13bf1ec6ccac463f51d13cf5711f92b","../nodes":"64f935a18a4d1c6fb56347b7941f194b"}],"9ea7046b75fd0d302632d8d5a6ed861b":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EventSubscriptionMutationIndex = exports.REMOVE_EVENT_SUBSCRIPTION_LENGTH = exports.RemoveEventRegistrationIndex = exports.ADD_EVENT_SUBSCRIPTION_LENGTH = exports.AddEventRegistrationIndex = exports.TransferrableTouchIndex = void 0;

var _TransferrableKeys = require("./TransferrableKeys");

/**
 * Copyright 2019 The AMP HTML Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let TransferrableTouchIndex;
exports.TransferrableTouchIndex = TransferrableTouchIndex;

(function (TransferrableTouchIndex) {
  TransferrableTouchIndex[TransferrableTouchIndex["Identifier"] = 0] = "Identifier";
  TransferrableTouchIndex[TransferrableTouchIndex["ScreenX"] = 1] = "ScreenX";
  TransferrableTouchIndex[TransferrableTouchIndex["ScreenY"] = 2] = "ScreenY";
  TransferrableTouchIndex[TransferrableTouchIndex["ClientX"] = 3] = "ClientX";
  TransferrableTouchIndex[TransferrableTouchIndex["ClientY"] = 4] = "ClientY";
  TransferrableTouchIndex[TransferrableTouchIndex["PageX"] = 5] = "PageX";
  TransferrableTouchIndex[TransferrableTouchIndex["PageY"] = 6] = "PageY";
  TransferrableTouchIndex[TransferrableTouchIndex["Target"] = 7] = "Target";
})(TransferrableTouchIndex || (exports.TransferrableTouchIndex = TransferrableTouchIndex = {}));

/**
 * Add Event Registration Transfer
 *
 * [
 *   type,
 *   index,
 *   capture,
 *   once,
 *   passive,
 *   workerDOMPreventDefault
 * ]
 */
let AddEventRegistrationIndex;
exports.AddEventRegistrationIndex = AddEventRegistrationIndex;

(function (AddEventRegistrationIndex) {
  AddEventRegistrationIndex[AddEventRegistrationIndex["Type"] = 0] = "Type";
  AddEventRegistrationIndex[AddEventRegistrationIndex["Index"] = 1] = "Index";
  AddEventRegistrationIndex[AddEventRegistrationIndex["Capture"] = 2] = "Capture";
  AddEventRegistrationIndex[AddEventRegistrationIndex["Once"] = 3] = "Once";
  AddEventRegistrationIndex[AddEventRegistrationIndex["Passive"] = 4] = "Passive";
  AddEventRegistrationIndex[AddEventRegistrationIndex["WorkerDOMPreventDefault"] = 5] = "WorkerDOMPreventDefault";
})(AddEventRegistrationIndex || (exports.AddEventRegistrationIndex = AddEventRegistrationIndex = {}));

const ADD_EVENT_SUBSCRIPTION_LENGTH = 6;
/**
 * Remove Event Registration Transfer
 */

exports.ADD_EVENT_SUBSCRIPTION_LENGTH = ADD_EVENT_SUBSCRIPTION_LENGTH;
let RemoveEventRegistrationIndex;
exports.RemoveEventRegistrationIndex = RemoveEventRegistrationIndex;

(function (RemoveEventRegistrationIndex) {
  RemoveEventRegistrationIndex[RemoveEventRegistrationIndex["Type"] = 0] = "Type";
  RemoveEventRegistrationIndex[RemoveEventRegistrationIndex["Index"] = 1] = "Index";
})(RemoveEventRegistrationIndex || (exports.RemoveEventRegistrationIndex = RemoveEventRegistrationIndex = {}));

const REMOVE_EVENT_SUBSCRIPTION_LENGTH = 2;
/**
 * Event Subscription Transfer
 *
 * [
 *   TransferrableMutationType.EVENT_SUBSCRIPTION,
 *   Target.index,
 *   RemoveEventListener.count,
 *   AddEventListener.count,
 *   ...RemoveEvent<RemoveEventRegistration>,
 *   ...AddEvent<AddEventRegistration>,
 * ]
 */

exports.REMOVE_EVENT_SUBSCRIPTION_LENGTH = REMOVE_EVENT_SUBSCRIPTION_LENGTH;
let EventSubscriptionMutationIndex;
exports.EventSubscriptionMutationIndex = EventSubscriptionMutationIndex;

(function (EventSubscriptionMutationIndex) {
  EventSubscriptionMutationIndex[EventSubscriptionMutationIndex["Target"] = 1] = "Target";
  EventSubscriptionMutationIndex[EventSubscriptionMutationIndex["RemoveEventListenerCount"] = 2] = "RemoveEventListenerCount";
  EventSubscriptionMutationIndex[EventSubscriptionMutationIndex["AddEventListenerCount"] = 3] = "AddEventListenerCount";
  EventSubscriptionMutationIndex[EventSubscriptionMutationIndex["Events"] = 4] = "Events";
  EventSubscriptionMutationIndex[EventSubscriptionMutationIndex["End"] = 4] = "End";
})(EventSubscriptionMutationIndex || (exports.EventSubscriptionMutationIndex = EventSubscriptionMutationIndex = {}));
},{"./TransferrableKeys":"38ecb3927f64cad8acafe7b8b5601eb5"}],"64f935a18a4d1c6fb56347b7941f194b":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NodeContext = exports.BASE_ELEMENT_INDEX = void 0;

var _TransferrableNodes = require("../transfer/TransferrableNodes");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * IE11 doesn't support NodeList.prototype.forEach
 * https://developer.mozilla.org/en-US/docs/Web/API/NodeList/forEach
 * @param list NodeList to iterate over
 * @param callback method to call with each node
 */
const nodeListEach = (list, callback) => Array.prototype.forEach.call(list, callback);

const BASE_ELEMENT_INDEX = 1;
exports.BASE_ELEMENT_INDEX = BASE_ELEMENT_INDEX;

class NodeContext {
  /**
   * Called when initializing a Worker, ensures the nodes in baseElement are
   * known for transmission into the Worker and future mutation events from the
   * Worker.
   * @param baseElement Element that will be controlled by a Worker
   */
  constructor(stringContext, baseElement) {
    _defineProperty(this, "createNodes", (buffer, sanitizer) => {
      const nodeBuffer = new Uint16Array(buffer);
      const nodeBufferLength = nodeBuffer.length;

      for (let iterator = 0; iterator < nodeBufferLength; iterator += _TransferrableNodes.TransferrableNodeIndex.End) {
        let node;

        if (nodeBuffer[iterator + _TransferrableNodes.TransferrableNodeIndex.NodeType] === _TransferrableNodes.NodeType.TEXT_NODE) {
          node = document.createTextNode(this.stringContext.get(nodeBuffer[iterator + _TransferrableNodes.TransferrableNodeIndex.TextContent]));
        } else if (nodeBuffer[iterator + _TransferrableNodes.TransferrableNodeIndex.NodeType] === _TransferrableNodes.NodeType.COMMENT_NODE) {
          node = document.createComment(this.stringContext.get(nodeBuffer[iterator + _TransferrableNodes.TransferrableNodeIndex.TextContent]));
        } else if (nodeBuffer[iterator + _TransferrableNodes.TransferrableNodeIndex.NodeType] === _TransferrableNodes.NodeType.DOCUMENT_FRAGMENT_NODE) {
          node = document.createDocumentFragment();
        } else {
          const nodeName = this.stringContext.get(nodeBuffer[iterator + _TransferrableNodes.TransferrableNodeIndex.NodeName]);
          node = nodeBuffer[iterator + _TransferrableNodes.TransferrableNodeIndex.Namespace] !== 0 ? document.createElementNS(this.stringContext.get(nodeBuffer[iterator + _TransferrableNodes.TransferrableNodeIndex.Namespace]), nodeName) : document.createElement(nodeName); // TODO(KB): Restore Properties
          // skeleton.properties.forEach(property => {
          //   node[`${property.name}`] = property.value;
          // });
          // ((skeleton as TransferrableElement)[TransferrableKeys.childNodes] || []).forEach(childNode => {
          //   if (childNode[TransferrableKeys.transferred] === NumericBoolean.FALSE) {
          //     node.appendChild(this.createNode(childNode as TransferrableNode));
          //   }
          // });
          // If `node` is removed by the sanitizer, don't store it and return null.

          if (sanitizer && !sanitizer.sanitize(node)) {
            continue;
          }
        }

        this.storeNode(node, nodeBuffer[iterator]);
      }
    });

    _defineProperty(this, "getNode", id => {
      const node = this.nodes.get(id);

      if (node && node.nodeName === 'BODY') {
        // If the node requested is the "BODY"
        // Then we return the base node this specific <amp-script> comes from.
        // This encapsulates each <amp-script> node.
        return this.baseElement;
      }

      return node;
    });

    _defineProperty(this, "storeNodes", node => {
      this.storeNode(node, ++this.count);
      nodeListEach(node.childNodes, n => this.storeNodes(n));
    });

    this.count = 2;
    this.stringContext = stringContext; // The nodes map is populated with two default values pointing to baseElement.
    // These are [document, document.body] from the worker.

    this.nodes = new Map([[BASE_ELEMENT_INDEX, baseElement], [2, baseElement]]);
    this.baseElement = baseElement; // To ensure a lookup works correctly from baseElement
    // add an index equal to the background thread document.body.

    baseElement._index_ = 2; // Lastly, it's important while initializing the document that we store
    // the default nodes present in the server rendered document.

    nodeListEach(baseElement.childNodes, n => this.storeNodes(n));
  }

  /**
   * Establish link between DOM `node` and worker-generated identifier `id`.
   *
   * These _shouldn't_ collide between instances of <amp-script> since
   * each element creates it's own pool on both sides of the worker
   * communication bridge.
   * @param node
   * @param id
   */
  storeNode(node, id) {
    node._index_ = id;
    this.nodes.set(id, node);
  }

}

exports.NodeContext = NodeContext;
},{"../transfer/TransferrableNodes":"a60b7ec2b30b96d412926079ae916dec"}],"a60b7ec2b30b96d412926079ae916dec":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TransferrableNodeIndex = exports.TransferredNodeIndex = exports.NodeType = exports.SVG_NAMESPACE = exports.HTML_NAMESPACE = void 0;

var _TransferrableKeys = require("./TransferrableKeys");

/**
 * Copyright 2018 The AMP HTML Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
exports.HTML_NAMESPACE = HTML_NAMESPACE;
const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
exports.SVG_NAMESPACE = SVG_NAMESPACE;
let NodeType;
exports.NodeType = NodeType;

(function (NodeType) {
  NodeType[NodeType["ELEMENT_NODE"] = 1] = "ELEMENT_NODE";
  NodeType[NodeType["ATTRIBUTE_NODE"] = 2] = "ATTRIBUTE_NODE";
  NodeType[NodeType["TEXT_NODE"] = 3] = "TEXT_NODE";
  NodeType[NodeType["CDATA_SECTION_NODE"] = 4] = "CDATA_SECTION_NODE";
  NodeType[NodeType["ENTITY_REFERENCE_NODE"] = 5] = "ENTITY_REFERENCE_NODE";
  NodeType[NodeType["ENTITY_NODE"] = 6] = "ENTITY_NODE";
  NodeType[NodeType["PROCESSING_INSTRUCTION_NODE"] = 7] = "PROCESSING_INSTRUCTION_NODE";
  NodeType[NodeType["COMMENT_NODE"] = 8] = "COMMENT_NODE";
  NodeType[NodeType["DOCUMENT_NODE"] = 9] = "DOCUMENT_NODE";
  NodeType[NodeType["DOCUMENT_TYPE_NODE"] = 10] = "DOCUMENT_TYPE_NODE";
  NodeType[NodeType["DOCUMENT_FRAGMENT_NODE"] = 11] = "DOCUMENT_FRAGMENT_NODE";
  NodeType[NodeType["NOTATION_NODE"] = 12] = "NOTATION_NODE";
})(NodeType || (exports.NodeType = NodeType = {}));

let TransferredNodeIndex;
exports.TransferredNodeIndex = TransferredNodeIndex;

(function (TransferredNodeIndex) {
  TransferredNodeIndex[TransferredNodeIndex["Index"] = 0] = "Index";
})(TransferredNodeIndex || (exports.TransferredNodeIndex = TransferredNodeIndex = {}));

let TransferrableNodeIndex;
exports.TransferrableNodeIndex = TransferrableNodeIndex;

(function (TransferrableNodeIndex) {
  TransferrableNodeIndex[TransferrableNodeIndex["Index"] = 0] = "Index";
  TransferrableNodeIndex[TransferrableNodeIndex["NodeType"] = 1] = "NodeType";
  TransferrableNodeIndex[TransferrableNodeIndex["NodeName"] = 2] = "NodeName";
  TransferrableNodeIndex[TransferrableNodeIndex["TextContent"] = 3] = "TextContent";
  TransferrableNodeIndex[TransferrableNodeIndex["Namespace"] = 4] = "Namespace";
  TransferrableNodeIndex[TransferrableNodeIndex["End"] = 5] = "End";
})(TransferrableNodeIndex || (exports.TransferrableNodeIndex = TransferrableNodeIndex = {}));
},{"./TransferrableKeys":"38ecb3927f64cad8acafe7b8b5601eb5"}],"c81681b06bf35c68ff927a26fe3a78c6":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BoundingClientRectProcessor = void 0;

var _TransferrableKeys = require("../../transfer/TransferrableKeys");

var _Messages = require("../../transfer/Messages");

var _TransferrableBoundClientRect = require("../../transfer/TransferrableBoundClientRect");

var _TransferrableMutation = require("../../transfer/TransferrableMutation");

/**
 * Copyright 2018 The AMP HTML Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const BoundingClientRectProcessor = (strings, nodes, workerContext, objectContext, config) => {
  const allowedExecution = config.executorsAllowed.includes(_TransferrableMutation.TransferrableMutationType.GET_BOUNDING_CLIENT_RECT);
  return {
    execute(mutations, startPosition, allowedMutation) {
      if (allowedExecution && allowedMutation) {
        const targetIndex = mutations[startPosition + _TransferrableBoundClientRect.BoundClientRectMutationIndex.Target];
        const target = nodes.getNode(targetIndex);

        if (target) {
          const boundingRect = target.getBoundingClientRect();
          workerContext.messageToWorker({
            [_TransferrableKeys.TransferrableKeys.type]: _Messages.MessageType.GET_BOUNDING_CLIENT_RECT,
            [_TransferrableKeys.TransferrableKeys.target]: [target._index_],
            [_TransferrableKeys.TransferrableKeys.data]: [boundingRect.top, boundingRect.right, boundingRect.bottom, boundingRect.left, boundingRect.width, boundingRect.height]
          });
        } else {
          console.error(`GET_BOUNDING_CLIENT_RECT: getNode(${targetIndex}) is null.`);
        }
      }

      return startPosition + _TransferrableBoundClientRect.BoundClientRectMutationIndex.End;
    },

    print(mutations, startPosition) {
      const targetIndex = mutations[startPosition + _TransferrableBoundClientRect.BoundClientRectMutationIndex.Target];
      const target = nodes.getNode(targetIndex);
      return {
        type: 'GET_BOUNDING_CLIENT_RECT',
        target,
        allowedExecution
      };
    }

  };
};

exports.BoundingClientRectProcessor = BoundingClientRectProcessor;
},{"../../transfer/TransferrableKeys":"38ecb3927f64cad8acafe7b8b5601eb5","../../transfer/Messages":"99507ba4e687c3fb9b635299dae9953c","../../transfer/TransferrableBoundClientRect":"b1e5db338b600a0e17a5362a0b37e000","../../transfer/TransferrableMutation":"d13bf1ec6ccac463f51d13cf5711f92b"}],"b1e5db338b600a0e17a5362a0b37e000":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.BoundClientRectMutationIndex = void 0;

/**
 * Copyright 2019 The AMP HTML Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let BoundClientRectMutationIndex; // [top, right, bottom, left, width, height]

exports.BoundClientRectMutationIndex = BoundClientRectMutationIndex;

(function (BoundClientRectMutationIndex) {
  BoundClientRectMutationIndex[BoundClientRectMutationIndex["Target"] = 1] = "Target";
  BoundClientRectMutationIndex[BoundClientRectMutationIndex["End"] = 2] = "End";
})(BoundClientRectMutationIndex || (exports.BoundClientRectMutationIndex = BoundClientRectMutationIndex = {}));
},{}],"92b936715fd22b6d1de0be422ee67e26":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ChildListProcessor = void 0;

var _TransferrableMutation = require("../../transfer/TransferrableMutation");

var _eventSubscription = require("./event-subscription");

/**
 * Copyright 2019 The AMP HTML Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ChildListProcessor = (strings, {
  getNode
}, workerContext, objectContext, config) => {
  const allowedExecution = config.executorsAllowed.includes(_TransferrableMutation.TransferrableMutationType.CHILD_LIST);
  return {
    execute(mutations, startPosition, allowedMutation) {
      const appendNodeCount = mutations[startPosition + _TransferrableMutation.ChildListMutationIndex.AppendedNodeCount];
      const removeNodeCount = mutations[startPosition + _TransferrableMutation.ChildListMutationIndex.RemovedNodeCount];

      if (allowedExecution && allowedMutation) {
        const targetIndex = mutations[startPosition + _TransferrableMutation.ChildListMutationIndex.Target];
        const target = getNode(targetIndex);

        if (target) {
          if (removeNodeCount > 0) {
            mutations.slice(startPosition + _TransferrableMutation.ChildListMutationIndex.Nodes + appendNodeCount, startPosition + _TransferrableMutation.ChildListMutationIndex.Nodes + appendNodeCount + removeNodeCount).forEach(removeId => {
              const node = getNode(removeId);

              if (node) {
                node.remove();
              } else {
                console.error(`CHILD_LIST: getNode(${removeId}) is null.`);
              }
            });
          }

          if (appendNodeCount > 0) {
            mutations.slice(startPosition + _TransferrableMutation.ChildListMutationIndex.Nodes, startPosition + _TransferrableMutation.ChildListMutationIndex.Nodes + appendNodeCount).forEach(addId => {
              const nextSibling = mutations[startPosition + _TransferrableMutation.ChildListMutationIndex.NextSibling];
              const newNode = getNode(addId);

              if (newNode) {
                // TODO: Handle this case ---
                // Transferred nodes that are not stored were previously removed by the sanitizer.
                target.insertBefore(newNode, nextSibling && getNode(nextSibling) || null);
                (0, _eventSubscription.applyDefaultInputListener)(workerContext, newNode);
                (0, _eventSubscription.sendValueChangeOnAttributeMutation)(workerContext, newNode);
              }
            });
          }
        } else {
          console.error(`CHILD_LIST: getNode(${targetIndex}) is null.`);
        }
      }

      return startPosition + _TransferrableMutation.ChildListMutationIndex.End + appendNodeCount + removeNodeCount;
    },

    print(mutations, startPosition) {
      const targetIndex = mutations[startPosition + _TransferrableMutation.ChildListMutationIndex.Target];
      const target = getNode(targetIndex);
      const appendNodeCount = mutations[startPosition + _TransferrableMutation.ChildListMutationIndex.AppendedNodeCount];
      const removeNodeCount = mutations[startPosition + _TransferrableMutation.ChildListMutationIndex.RemovedNodeCount];
      const removedNodes = Array.from(mutations.slice(startPosition + _TransferrableMutation.ChildListMutationIndex.Nodes + appendNodeCount, startPosition + _TransferrableMutation.ChildListMutationIndex.Nodes + appendNodeCount + removeNodeCount)).map(index => getNode(index) || index);
      const addedNodes = Array.from(mutations.slice(startPosition + _TransferrableMutation.ChildListMutationIndex.Nodes, startPosition + _TransferrableMutation.ChildListMutationIndex.Nodes + appendNodeCount)).map(index => getNode(index) || index);
      return {
        target,
        allowedExecution,
        nextSibling: getNode(mutations[startPosition + _TransferrableMutation.ChildListMutationIndex.NextSibling]) || null,
        previousSibling: getNode(mutations[startPosition + _TransferrableMutation.ChildListMutationIndex.PreviousSibling]) || null,
        addedNodes,
        removedNodes
      };
    }

  };
};

exports.ChildListProcessor = ChildListProcessor;
},{"../../transfer/TransferrableMutation":"d13bf1ec6ccac463f51d13cf5711f92b","./event-subscription":"d5f875a605c8e7c7352a153b4110f36e"}],"6988f77df2ebeac26e7a287ebe414754":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.AttributeProcessor = void 0;

var _TransferrableMutation = require("../../transfer/TransferrableMutation");

/**
 * Copyright 2019 The AMP HTML Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const AttributeProcessor = (strings, nodes, workerContext, objectContext, config) => {
  const allowedExecution = config.executorsAllowed.includes(_TransferrableMutation.TransferrableMutationType.ATTRIBUTES);
  /**
   * @param mutations
   * @param startPosition
   */

  const getValue = (mutations, startPosition) => {
    const value = mutations[startPosition + _TransferrableMutation.AttributeMutationIndex.Value]; // Value is sent as 0 when it's the default value or removal.
    // Value is sent as index + 1 when it's a valid value.

    return value !== 0 ? strings.get(value - 1) : null;
  };

  return {
    execute(mutations, startPosition, allowedMutation) {
      if (allowedExecution && allowedMutation) {
        const targetIndex = mutations[startPosition + _TransferrableMutation.AttributeMutationIndex.Target];
        const target = nodes.getNode(targetIndex);
        const attributeName = strings.get(mutations[startPosition + _TransferrableMutation.AttributeMutationIndex.Name]);
        const value = getValue(mutations, startPosition);

        if (target) {
          if (attributeName != null) {
            if (config.sanitizer) {
              const mutated = config.sanitizer.setAttribute(target, attributeName, value);

              if (!mutated) {// TODO(choumx): Inform worker that sanitizer ignored unsafe attribute value change.
              }
            } else {
              if (value == null) {
                target.removeAttribute(attributeName);
              } else {
                target.setAttribute(attributeName, value);
              }
            }
          }
        } else {
          console.error(`ATTR_LIST: getNode(${targetIndex}) is null.`);
        }
      }

      return startPosition + _TransferrableMutation.AttributeMutationIndex.End;
    },

    print(mutations, startPosition) {
      const targetIndex = mutations[startPosition + _TransferrableMutation.AttributeMutationIndex.Target];
      const target = nodes.getNode(targetIndex);
      const attributeName = strings.get(mutations[startPosition + _TransferrableMutation.AttributeMutationIndex.Name]);
      const value = getValue(mutations, startPosition);
      return {
        target,
        allowedExecution,
        attributeName,
        value,
        remove: value == null
      };
    }

  };
};

exports.AttributeProcessor = AttributeProcessor;
},{"../../transfer/TransferrableMutation":"d13bf1ec6ccac463f51d13cf5711f92b"}],"49fdf912bdc8ded6204712ec5580b042":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CharacterDataProcessor = void 0;

var _TransferrableMutation = require("../../transfer/TransferrableMutation");

/**
 * Copyright 2019 The AMP HTML Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const CharacterDataProcessor = (strings, nodes, workerContext, objectContext, config) => {
  const allowedExecution = config.executorsAllowed.includes(_TransferrableMutation.TransferrableMutationType.CHARACTER_DATA);
  return {
    execute(mutations, startPosition, allowedMutation) {
      if (allowedExecution && allowedMutation) {
        const targetIndex = mutations[startPosition + _TransferrableMutation.CharacterDataMutationIndex.Target];
        const target = nodes.getNode(targetIndex);
        const value = mutations[startPosition + _TransferrableMutation.CharacterDataMutationIndex.Value];

        if (target) {
          if (value) {
            // Sanitization not necessary for textContent.
            target.textContent = strings.get(value);
          }
        } else {
          console.error(`CHAR_DATA: getNode(${targetIndex}) is null.`);
        }
      }

      return startPosition + _TransferrableMutation.CharacterDataMutationIndex.End;
    },

    print(mutations, startPosition) {
      const targetIndex = mutations[startPosition + _TransferrableMutation.CharacterDataMutationIndex.Target];
      const target = nodes.getNode(targetIndex);
      return {
        target,
        allowedExecution,
        value: strings.get(mutations[startPosition + _TransferrableMutation.CharacterDataMutationIndex.Value])
      };
    }

  };
};

exports.CharacterDataProcessor = CharacterDataProcessor;
},{"../../transfer/TransferrableMutation":"d13bf1ec6ccac463f51d13cf5711f92b"}],"74dd53a753e8b7eabf5f43632bc09feb":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PropertyProcessor = void 0;

var _TransferrableMutation = require("../../transfer/TransferrableMutation");

var _utils = require("../../utils");

/**
 * Copyright 2019 The AMP HTML Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const PropertyProcessor = (strings, nodeContext, workerContext, objectContext, config) => {
  const allowedExecution = config.executorsAllowed.includes(_TransferrableMutation.TransferrableMutationType.PROPERTIES);

  const getValue = (mutations, startPosition) => {
    const value = mutations[startPosition + _TransferrableMutation.PropertyMutationIndex.Value];

    if (mutations[startPosition + _TransferrableMutation.PropertyMutationIndex.IsBoolean] === _utils.NumericBoolean.TRUE) {
      return value === _utils.NumericBoolean.TRUE;
    }

    if (value !== 0) {
      return strings.get(value);
    }

    return null;
  };

  return {
    execute(mutations, startPosition, allowedMutation) {
      if (allowedExecution && allowedMutation) {
        const targetIndex = mutations[startPosition + _TransferrableMutation.PropertyMutationIndex.Target];
        const target = nodeContext.getNode(targetIndex);
        const name = strings.get(mutations[startPosition + _TransferrableMutation.PropertyMutationIndex.Name]);
        const value = getValue(mutations, startPosition);

        if (target) {
          if (name && value != null) {
            if (config.sanitizer) {
              const mutated = config.sanitizer.setProperty(target, name, String(value));

              if (!mutated) {// TODO(choumx): Inform worker that sanitizer ignored unsafe property value change.
              }
            } else {
              target[name] = value;
            }
          }
        } else {
          console.error(`PROPERTY: getNode(${targetIndex}) is null.`);
        }
      }

      return startPosition + _TransferrableMutation.PropertyMutationIndex.End;
    },

    print(mutations, startPosition) {
      const targetIndex = mutations[startPosition + _TransferrableMutation.PropertyMutationIndex.Target];
      const target = nodeContext.getNode(targetIndex);
      const name = strings.get(mutations[startPosition + _TransferrableMutation.PropertyMutationIndex.Name]);
      const value = getValue(mutations, startPosition);
      return {
        target,
        name,
        value,
        allowedExecution
      };
    }

  };
};

exports.PropertyProcessor = PropertyProcessor;
},{"../../transfer/TransferrableMutation":"d13bf1ec6ccac463f51d13cf5711f92b","../../utils":"b823de61bf5e9fca299c60d0b56af8c5"}],"b823de61bf5e9fca299c60d0b56af8c5":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.NumericBoolean = exports.keyValueString = exports.containsIndexOf = exports.toUpper = exports.toLower = void 0;

/**
 * Copyright 2018 The AMP HTML Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const toLower = value => value.toLowerCase();

exports.toLower = toLower;

const toUpper = value => value.toUpperCase();

exports.toUpper = toUpper;

const containsIndexOf = pos => pos !== -1;

exports.containsIndexOf = containsIndexOf;

const keyValueString = (key, value) => `${key}="${value}"`;

exports.keyValueString = keyValueString;
let NumericBoolean;
exports.NumericBoolean = NumericBoolean;

(function (NumericBoolean) {
  NumericBoolean[NumericBoolean["FALSE"] = 0] = "FALSE";
  NumericBoolean[NumericBoolean["TRUE"] = 1] = "TRUE";
})(NumericBoolean || (exports.NumericBoolean = NumericBoolean = {}));
},{}],"87ee9f055fac46fbdeff97c473204064":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LongTaskExecutor = void 0;

var _TransferrableMutation = require("../../transfer/TransferrableMutation");

/**
 * Copyright 2019 The AMP HTML Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const LongTaskExecutor = (stringContext, nodeContext, workerContext, objectContext, config) => {
  const allowedExecution = config.executorsAllowed.includes(_TransferrableMutation.TransferrableMutationType.LONG_TASK_START);
  let index = 0;
  let currentResolver;
  return {
    execute(mutations, startPosition, allowedMutation) {
      if (allowedExecution && allowedMutation && config.longTask) {
        if (mutations[startPosition] === _TransferrableMutation.TransferrableMutationType.LONG_TASK_START) {
          index++;

          if (!currentResolver) {
            config.longTask(new Promise(resolve => currentResolver = resolve));
          }
        } else if (mutations[startPosition] === _TransferrableMutation.TransferrableMutationType.LONG_TASK_END) {
          index--;

          if (currentResolver && index <= 0) {
            currentResolver();
            currentResolver = null;
            index = 0;
          }
        }
      }

      return startPosition + _TransferrableMutation.LongTaskMutationIndex.End;
    },

    print(mutations, startPosition) {
      return {
        type: _TransferrableMutation.ReadableMutationType[mutations[startPosition]],
        allowedExecution
      };
    },

    get active() {
      return currentResolver !== null;
    }

  };
};

exports.LongTaskExecutor = LongTaskExecutor;
},{"../../transfer/TransferrableMutation":"d13bf1ec6ccac463f51d13cf5711f92b"}],"3a760954c58805bac97f0afd5021917b":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ObjectMutationProcessor = void 0;

var _TransferrableMutation = require("../../transfer/TransferrableMutation");

var _deserializeTransferrableObject = require("../deserializeTransferrableObject");

/**
 * Copyright 2019 The AMP HTML Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ObjectMutationProcessor = (strings, nodeContext, workerContext, objectContext, config) => {
  const allowedExecution = config.executorsAllowed.includes(_TransferrableMutation.TransferrableMutationType.OBJECT_MUTATION);
  return {
    execute(mutations, startPosition, allowedMutation) {
      const functionName = strings.get(mutations[startPosition + _TransferrableMutation.ObjectMutationIndex.FunctionName]);
      const argCount = mutations[startPosition + _TransferrableMutation.ObjectMutationIndex.ArgumentCount];
      const {
        offset: targetOffset,
        args: deserializedTarget
      } = (0, _deserializeTransferrableObject.deserializeTransferrableObject)(mutations, startPosition + _TransferrableMutation.ObjectMutationIndex.SerializedTarget, 1, strings, nodeContext, objectContext);
      const target = deserializedTarget[0];
      const {
        offset: argsOffset,
        args
      } = (0, _deserializeTransferrableObject.deserializeTransferrableObject)(mutations, targetOffset, argCount, strings, nodeContext, objectContext);

      if (allowedExecution && allowedMutation) {
        if (isSetter(target, functionName)) {
          target[functionName] = args[0];
        } else {
          target[functionName](...args);
        }
      }

      return argsOffset;
    },

    print(mutations, startPosition) {
      const functionName = strings.get(mutations[startPosition + _TransferrableMutation.ObjectMutationIndex.FunctionName]);
      const {
        args: deserializedTarget
      } = (0, _deserializeTransferrableObject.deserializeTransferrableObject)(mutations, startPosition + _TransferrableMutation.ObjectMutationIndex.SerializedTarget, 1, strings, nodeContext, objectContext);
      const target = deserializedTarget[0];
      return {
        type: 'OBJECT_MUTATION',
        target,
        functionName,
        isSetter: isSetter(target, functionName),
        allowedExecution
      };
    }

  };
};

exports.ObjectMutationProcessor = ObjectMutationProcessor;

function isSetter(object, name) {
  if (!object) {
    throw new Error(`Property ${name} does not exist on ${object}.`);
  }

  const descriptor = Object.getOwnPropertyDescriptor(object, name);

  if (descriptor !== undefined) {
    return 'set' in descriptor;
  }

  return isSetter(Object.getPrototypeOf(object), name);
}
},{"../../transfer/TransferrableMutation":"d13bf1ec6ccac463f51d13cf5711f92b","../deserializeTransferrableObject":"87387d1094f11f862e68afef4bdc92f2"}],"87387d1094f11f862e68afef4bdc92f2":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deserializeTransferrableObject = deserializeTransferrableObject;

var _TransferrableMutation = require("../transfer/TransferrableMutation");

/**
 * Copyright 2019 The AMP HTML Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const f32 = new Float32Array(1);
const u16 = new Uint16Array(f32.buffer);
/**
 * Deserializes TransferrableObjectType arguments.
 * @param buffer Contains mutation with arguments to deserialize.
 * @param offset Start position of arguments in mutations buffer.
 * @param count Number of arguments to deserialize.
 * @param stringContext Strings context.
 * @param nodeContext Nodes context.
 * @param objectContext Objects context
 */

function deserializeTransferrableObject(buffer, offset, count, stringContext, nodeContext, objectContext) {
  const args = [];

  for (let i = 0; i < count; i++) {
    switch (buffer[offset++]) {
      case _TransferrableMutation.TransferrableObjectType.SmallInt:
        args.push(buffer[offset++]);
        break;

      case _TransferrableMutation.TransferrableObjectType.Float:
        u16[0] = buffer[offset++];
        u16[1] = buffer[offset++];
        args.push(f32[0]);
        break;

      case _TransferrableMutation.TransferrableObjectType.String:
        args.push(stringContext.get(buffer[offset++]));
        break;

      case _TransferrableMutation.TransferrableObjectType.Array:
        const size = buffer[offset++];
        const des = deserializeTransferrableObject(buffer, offset, size, stringContext, nodeContext, objectContext);
        args.push(des.args);
        offset = des.offset;
        break;

      case _TransferrableMutation.TransferrableObjectType.TransferObject:
        if (!objectContext) {
          throw new Error('objectContext not provided.');
        }

        args.push(objectContext.get(buffer[offset++]));
        break;

      case _TransferrableMutation.TransferrableObjectType.CanvasRenderingContext2D:
        const canvas = nodeContext.getNode(buffer[offset++]);
        args.push(canvas.getContext('2d'));
        break;

      case _TransferrableMutation.TransferrableObjectType.HTMLElement:
        args.push(nodeContext.getNode(buffer[offset++]));
        break;

      default:
        throw new Error('Cannot deserialize argument.');
    }
  }

  return {
    args,
    offset
  };
}
},{"../transfer/TransferrableMutation":"d13bf1ec6ccac463f51d13cf5711f92b"}],"ba827ede0e5e4a3cc92dd40c41a947be":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ObjectCreationProcessor = void 0;

var _TransferrableMutation = require("../../transfer/TransferrableMutation");

var _deserializeTransferrableObject = require("../deserializeTransferrableObject");

/**
 * Copyright 2019 The AMP HTML Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ObjectCreationProcessor = (strings, nodeContext, workerContext, objectContext, config) => {
  const allowedExecution = config.executorsAllowed.includes(_TransferrableMutation.TransferrableMutationType.OBJECT_CREATION);

  if (!objectContext) {
    throw new Error('objectContext is not defined.');
  }

  return {
    execute(mutations, startPosition, allowedMutation) {
      const functionName = strings.get(mutations[startPosition + _TransferrableMutation.ObjectCreationIndex.FunctionName]);
      const objectId = mutations[startPosition + _TransferrableMutation.ObjectCreationIndex.ObjectId];
      const argCount = mutations[startPosition + _TransferrableMutation.ObjectCreationIndex.ArgumentCount];
      const {
        offset: targetOffset,
        args: deserializedTarget
      } = (0, _deserializeTransferrableObject.deserializeTransferrableObject)(mutations, startPosition + _TransferrableMutation.ObjectCreationIndex.SerializedTarget, 1, // argCount
      strings, nodeContext, objectContext);
      const target = deserializedTarget[0];
      const {
        offset: argsOffset,
        args
      } = (0, _deserializeTransferrableObject.deserializeTransferrableObject)(mutations, targetOffset, argCount, strings, nodeContext, objectContext);

      if (allowedExecution && allowedMutation) {
        if (functionName === 'new') {// deal with constructor case here
        } else {
          objectContext.store(objectId, target[functionName](...args));
        }
      }

      return argsOffset;
    },

    print(mutations, startPosition) {
      const functionName = strings.get(mutations[startPosition + _TransferrableMutation.ObjectCreationIndex.FunctionName]);
      const objectId = mutations[startPosition + _TransferrableMutation.ObjectCreationIndex.ObjectId];
      const argCount = mutations[startPosition + _TransferrableMutation.ObjectCreationIndex.ArgumentCount];
      const {
        args: deserializedTarget
      } = (0, _deserializeTransferrableObject.deserializeTransferrableObject)(mutations, startPosition + _TransferrableMutation.ObjectCreationIndex.SerializedTarget, 1, // argCount
      strings, nodeContext, objectContext);
      const target = deserializedTarget[0];
      return {
        type: 'OBJECT_CREATION',
        target,
        functionName,
        objectId,
        argCount,
        allowedExecution
      };
    }

  };
};

exports.ObjectCreationProcessor = ObjectCreationProcessor;
},{"../../transfer/TransferrableMutation":"d13bf1ec6ccac463f51d13cf5711f92b","../deserializeTransferrableObject":"87387d1094f11f862e68afef4bdc92f2"}],"2d11db9497d2247c150bddb26396c8ca":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ImageBitmapProcessor = void 0;

var _TransferrableMutation = require("../../transfer/TransferrableMutation");

var _TransferrableKeys = require("../../transfer/TransferrableKeys");

var _Messages = require("../../transfer/Messages");

/**
 * Copyright 2019 The AMP HTML Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ImageBitmapProcessor = (strings, nodeContext, workerContext, objectContext, config) => {
  const allowedExecution = config.executorsAllowed.includes(_TransferrableMutation.TransferrableMutationType.IMAGE_BITMAP_INSTANCE);
  return {
    execute(mutations, startPosition, allowedMutation) {
      if (allowedExecution && allowedMutation) {
        const targetIndex = mutations[startPosition + _TransferrableMutation.ImageBitmapMutationIndex.Target];
        const target = nodeContext.getNode(targetIndex);

        if (target) {
          self.createImageBitmap(target).then(imageBitmap => {
            workerContext.messageToWorker({
              [_TransferrableKeys.TransferrableKeys.type]: _Messages.MessageType.IMAGE_BITMAP_INSTANCE,
              [_TransferrableKeys.TransferrableKeys.callIndex]: mutations[startPosition + _TransferrableMutation.ImageBitmapMutationIndex.CallIndex],
              [_TransferrableKeys.TransferrableKeys.data]: imageBitmap
            }, [imageBitmap]);
          });
        } else {
          console.error(`IMAGE_BITMAP_INSTANCE: getNode(${targetIndex}) is null.`);
        }
      }

      return startPosition + _TransferrableMutation.ImageBitmapMutationIndex.End;
    },

    print(mutations, startPosition) {
      const targetIndex = mutations[startPosition + _TransferrableMutation.ImageBitmapMutationIndex.Target];
      const target = nodeContext.getNode(targetIndex);
      return {
        type: 'IMAGE_BITMAP_INSTANCE',
        target,
        allowedExecution,
        callIndex: mutations[startPosition + _TransferrableMutation.ImageBitmapMutationIndex.CallIndex]
      };
    }

  };
};

exports.ImageBitmapProcessor = ImageBitmapProcessor;
},{"../../transfer/TransferrableMutation":"d13bf1ec6ccac463f51d13cf5711f92b","../../transfer/TransferrableKeys":"38ecb3927f64cad8acafe7b8b5601eb5","../../transfer/Messages":"99507ba4e687c3fb9b635299dae9953c"}],"20457afb7535d84044adb402cad2ec00":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StorageProcessor = void 0;

var _TransferrableMutation = require("../../transfer/TransferrableMutation");

var _TransferrableStorage = require("../../transfer/TransferrableStorage");

var _TransferrableKeys = require("../../transfer/TransferrableKeys");

var _Messages = require("../../transfer/Messages");

/**
 * Copyright 2019 The AMP HTML Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const StorageProcessor = (strings, nodeContext, workerContext, objectContext, config) => {
  const allowedExecution = config.executorsAllowed.includes(_TransferrableMutation.TransferrableMutationType.STORAGE);

  const get = (location, key) => {
    if (config.sanitizer && location === _TransferrableStorage.StorageLocation.AmpState) {
      config.sanitizer.getStorage(location, key).then(value => {
        const message = {
          [_TransferrableKeys.TransferrableKeys.type]: _Messages.MessageType.GET_STORAGE,
          [_TransferrableKeys.TransferrableKeys.storageKey]: key || '',
          [_TransferrableKeys.TransferrableKeys.storageLocation]: location,
          [_TransferrableKeys.TransferrableKeys.value]: value
        };
        workerContext.messageToWorker(message);
      });
    } else {
      console.error(`STORAGE: Sanitizer not found or unsupported location:`, location);
    }
  };

  const set = (location, key, value) => {
    if (config.sanitizer) {
      // TODO: Message worker so AMP.setState() can be Promise-able.
      config.sanitizer.setStorage(location, key, value);
    } else {
      let storage;

      if (location === _TransferrableStorage.StorageLocation.Local) {
        storage = window.localStorage;
      } else if (location === _TransferrableStorage.StorageLocation.Session) {
        storage = window.sessionStorage;
      }

      if (storage) {
        if (key == null) {
          if (value == null) {
            storage.clear();
          } else {
            throw new Error('Unexpected storage operation.');
          }
        } else {
          if (value == null) {
            storage.removeItem(key);
          } else {
            storage.setItem(key, value);
          }
        }
      } else {
        console.error(`STORAGE: Unexpected location: "${location}".`);
      }
    }
  };

  return {
    execute(mutations, startPosition, allowedMutation) {
      if (allowedExecution && allowedMutation) {
        const operation = mutations[startPosition + _TransferrableMutation.StorageMutationIndex.Operation];
        const location = mutations[startPosition + _TransferrableMutation.StorageMutationIndex.Location];
        const keyIndex = mutations[startPosition + _TransferrableMutation.StorageMutationIndex.Key];
        const valueIndex = mutations[startPosition + _TransferrableMutation.StorageMutationIndex.Value]; // TODO(choumx): Clean up key/value strings (or don't store them in the first place)
        // to avoid leaking memory.

        const key = keyIndex > 0 ? strings.get(keyIndex) : null;
        const value = valueIndex > 0 ? strings.get(valueIndex) : null;

        if (operation === _Messages.GetOrSet.GET) {
          get(location, key);
        } else if (operation === _Messages.GetOrSet.SET) {
          set(location, key, value);
        }
      }

      return startPosition + _TransferrableMutation.StorageMutationIndex.End;
    },

    print(mutations, startPosition) {
      const operation = mutations[startPosition + _TransferrableMutation.StorageMutationIndex.Operation];
      const location = mutations[startPosition + _TransferrableMutation.StorageMutationIndex.Location];
      const keyIndex = mutations[startPosition + _TransferrableMutation.StorageMutationIndex.Key];
      const valueIndex = mutations[startPosition + _TransferrableMutation.StorageMutationIndex.Value];
      const key = keyIndex > 0 ? strings.get(keyIndex) : null;
      const value = valueIndex > 0 ? strings.get(valueIndex) : null;
      return {
        type: 'STORAGE',
        operation,
        location,
        key,
        value,
        allowedExecution
      };
    }

  };
};

exports.StorageProcessor = StorageProcessor;
},{"../../transfer/TransferrableMutation":"d13bf1ec6ccac463f51d13cf5711f92b","../../transfer/TransferrableStorage":"e1eeaf3b87b3ab21b3c041740aa1d5d4","../../transfer/TransferrableKeys":"38ecb3927f64cad8acafe7b8b5601eb5","../../transfer/Messages":"99507ba4e687c3fb9b635299dae9953c"}],"e1eeaf3b87b3ab21b3c041740aa1d5d4":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StorageLocation = void 0;

/**
 * Copyright 2019 The AMP HTML Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let StorageLocation;
exports.StorageLocation = StorageLocation;

(function (StorageLocation) {
  StorageLocation[StorageLocation["Local"] = 0] = "Local";
  StorageLocation[StorageLocation["Session"] = 1] = "Session";
  StorageLocation[StorageLocation["AmpState"] = 2] = "AmpState";
})(StorageLocation || (exports.StorageLocation = StorageLocation = {}));
},{}],"da8cdd19aabb35c9fec1b151586a109a":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.registerPromise = registerPromise;
exports.FunctionProcessor = void 0;

var _TransferrableMutation = require("../../transfer/TransferrableMutation");

var _Messages = require("../../transfer/Messages");

/**
 * Copyright 2020 The AMP HTML Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let fnCallCount = 0;
/**
 * A mapping between each request to callFunction and its Promise.
 */

const promiseMap = {};
/**
 * Each invocation of `ExportedWorker.prototype.callFunction` needs to be registered with a unique index
 * and promise. The index is given to the underlying Worker and returned by it as well. That enables the main-thread to
 * correlate postMessage responses with their original requests and resolve/reject the correct Promise.
 */

function registerPromise() {
  // TS won't realize that the constructor promise assigns the handlers, so we `any` them.
  let resolve;
  let reject;
  const promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  }); // Wraparound to 0 in case someone attempts to register over 9 quadrillion promises.

  if (fnCallCount >= Number.MAX_VALUE) {
    fnCallCount = 0;
  }

  const index = fnCallCount++;
  promiseMap[index] = {
    promise,
    resolve,
    reject
  };
  return {
    promise,
    index
  };
}

const FunctionProcessor = (strings, nodeContext, workerContext, objectContext, config) => {
  const allowedExecution = config.executorsAllowed.includes(_TransferrableMutation.TransferrableMutationType.FUNCTION_CALL);
  return {
    execute(mutations, startPosition) {
      if (allowedExecution) {
        const status = mutations[startPosition + _TransferrableMutation.FunctionMutationIndex.Status];
        const index = mutations[startPosition + _TransferrableMutation.FunctionMutationIndex.Index];
        const value = mutations[startPosition + _TransferrableMutation.FunctionMutationIndex.Value];
        const parsed = strings.hasIndex(value) ? JSON.parse(strings.get(value)) : undefined;

        if (status === _Messages.ResolveOrReject.RESOLVE) {
          promiseMap[index].resolve(parsed);
        } else {
          promiseMap[index].reject(parsed);
        }

        delete promiseMap[index];
      }

      return startPosition + _TransferrableMutation.FunctionMutationIndex.End;
    },

    print(mutations, startPosition) {
      const status = mutations[startPosition + _TransferrableMutation.FunctionMutationIndex.Status];
      const index = mutations[startPosition + _TransferrableMutation.FunctionMutationIndex.Index];
      const value = mutations[startPosition + _TransferrableMutation.FunctionMutationIndex.Value];
      return {
        type: 'FUNCTION_INVOCATION',
        status,
        index,
        value: strings.get(value),
        allowedExecution
      };
    }

  };
};

exports.FunctionProcessor = FunctionProcessor;
},{"../../transfer/TransferrableMutation":"d13bf1ec6ccac463f51d13cf5711f92b","../../transfer/Messages":"99507ba4e687c3fb9b635299dae9953c"}],"9b8dafde2db2a949457a0b7100cb929c":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.StringContext = void 0;

/**
 * Copyright 2018 The AMP HTML Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Stores indexed strings that are used in postMessage() calls from the worker.
 */
class StringContext {
  constructor() {
    this.strings = [];
  }
  /**
   * Return a string for the specified index.
   * @param index string index to retrieve.
   * @return string in map for the index.
   */


  get(index) {
    return this.strings[index] || '';
  }

  hasIndex(index) {
    return this.strings[index] !== undefined;
  }
  /**
   * Stores a string in mapping and returns the index of the location.
   * @param value string to store
   * @return location in map
   */


  store(value) {
    this.strings.push(value);
  }
  /**
   * Stores a set of strings.
   * @param values
   */


  storeValues(values) {
    values.forEach(v => this.store(v));
  }

}

exports.StringContext = StringContext;
},{}],"d3372d52f19dda82de1cff2a4e8e1c46":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.normalizeConfiguration = normalizeConfiguration;

var _TransferrableMutation = require("../transfer/TransferrableMutation");

/**
 * Copyright 2018 The AMP HTML Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function normalizeConfiguration(config) {
  return Object.assign({}, {
    mutationPump: requestAnimationFrame.bind(null),
    executorsAllowed: _TransferrableMutation.DefaultAllowedMutations
  }, config);
}
},{"../transfer/TransferrableMutation":"d13bf1ec6ccac463f51d13cf5711f92b"}],"65e4ce607d8f5dbfbc362c57dbad5a23":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WorkerContext = void 0;

var _serialize = require("./serialize");

var _debugging = require("./debugging");

var _TransferrableKeys = require("../transfer/TransferrableKeys");

var _TransferrableStorage = require("../transfer/TransferrableStorage");

/**
 * Copyright 2018 The AMP HTML Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class WorkerContext {
  /**
   * @param baseElement
   * @param nodeContext
   * @param workerDOMScript
   * @param authorScript
   * @param config
   */
  constructor(baseElement, nodeContext, workerDOMScript, authorScript, config) {
    this.nodeContext = nodeContext;
    this.config = config;
    const {
      skeleton,
      strings
    } = (0, _serialize.createHydrateableRootNode)(baseElement, config, this);
    const cssKeys = [];
    const globalEventHandlerKeys = []; // TODO(choumx): Sync read of all localStorage and sessionStorage a possible performance bottleneck?

    const localStorageData = config.sanitizer ? config.sanitizer.getStorage(_TransferrableStorage.StorageLocation.Local) : window.localStorage;
    const sessionStorageData = config.sanitizer ? config.sanitizer.getStorage(_TransferrableStorage.StorageLocation.Session) : window.sessionStorage;

    for (const key in baseElement.style) {
      cssKeys.push(key);
    }

    for (const key in baseElement) {
      if (key.startsWith('on')) {
        globalEventHandlerKeys.push(key);
      }
    }

    const code = `
      'use strict';
      (function(){
        ${workerDOMScript}
        self['window'] = self;
        var workerDOM = WorkerThread.workerDOM;
        WorkerThread.hydrate(
          workerDOM.document,
          ${JSON.stringify(strings)},
          ${JSON.stringify(skeleton)},
          ${JSON.stringify(cssKeys)},
          ${JSON.stringify(globalEventHandlerKeys)},
          [${window.innerWidth}, ${window.innerHeight}],
          ${JSON.stringify(localStorageData)},
          ${JSON.stringify(sessionStorageData)}
        );
        workerDOM.document[${_TransferrableKeys.TransferrableKeys.observe}](this);
        Object.keys(workerDOM).forEach(function(k){self[k]=workerDOM[k]});
      }).call(self);
      ${authorScript}
      //# sourceURL=${encodeURI(config.authorURL)}`;
    this[_TransferrableKeys.TransferrableKeys.worker] = new Worker(URL.createObjectURL(new Blob([code])));

    if (undefined) {
      console.info('debug', 'hydratedNode', (0, _debugging.readableHydrateableRootNode)(baseElement, config, this));
    }

    if (config.onCreateWorker) {
      config.onCreateWorker(baseElement, strings, skeleton, cssKeys);
    }

    if (config.messageChannel) {
      this[_TransferrableKeys.TransferrableKeys.worker].addEventListener("message", e => config.messageChannel?.port2.postMessage(e.data, [e.data]));
    }
  }
  /**
   * Returns the private worker.
   */


  get worker() {
    return this[_TransferrableKeys.TransferrableKeys.worker];
  }
  /**
   * @param message
   */


  messageToWorker(message, transferables) {
    if (undefined) {
      console.info('debug', 'messageToWorker', (0, _debugging.readableMessageToWorker)(this.nodeContext, message));
    }

    if (this.config.onSendMessage) {
      this.config.onSendMessage(message, transferables || []);
    }

    if (this.config.messageChannel) {
      this.config.messageChannel.port1.postMessage(message, transferables || []);
    }

    this.worker.postMessage(message, transferables || []);
  }

}

exports.WorkerContext = WorkerContext;
},{"./serialize":"e5456ee0f968d64a068884d599db741d","./debugging":"a609320500f9a22ea17dba0d7cfadb6b","../transfer/TransferrableKeys":"38ecb3927f64cad8acafe7b8b5601eb5","../transfer/TransferrableStorage":"e1eeaf3b87b3ab21b3c041740aa1d5d4"}],"e5456ee0f968d64a068884d599db741d":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createHydrateableRootNode = createHydrateableRootNode;
exports.createReadableHydrateableRootNode = createReadableHydrateableRootNode;

var _TransferrableNodes = require("../transfer/TransferrableNodes");

var _TransferrableKeys = require("../transfer/TransferrableKeys");

var _utils = require("../utils");

var _eventSubscription = require("./commands/event-subscription");

/**
 * Copyright 2018 The AMP HTML Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const NODES_ALLOWED_TO_TRANSMIT_TEXT_CONTENT = [_TransferrableNodes.NodeType.COMMENT_NODE, _TransferrableNodes.NodeType.TEXT_NODE];
/**
 * Serializes a DOM element for transport to the worker.
 * @param element
 * @param minimizeString Function for minimizing strings for optimized ferrying across postMessage.
 */

function createHydrateableNode(element, minimizeString, hydrateFilter, workerContext) {
  const filteredChildNodes = [].slice.call(element.childNodes).filter(hydrateFilter);
  const hydrated = {
    [_TransferrableKeys.TransferrableKeys.index]: element._index_,
    [_TransferrableKeys.TransferrableKeys.transferred]: _utils.NumericBoolean.FALSE,
    [_TransferrableKeys.TransferrableKeys.nodeType]: element.nodeType,
    [_TransferrableKeys.TransferrableKeys.localOrNodeName]: minimizeString(element.localName || element.nodeName),
    [_TransferrableKeys.TransferrableKeys.childNodes]: filteredChildNodes.map(child => createHydrateableNode(child, minimizeString, hydrateFilter, workerContext)),
    [_TransferrableKeys.TransferrableKeys.attributes]: [].map.call(element.attributes || [], attribute => [minimizeString(attribute.namespaceURI || 'null'), minimizeString(attribute.name), minimizeString(attribute.value)])
  };

  if (element.namespaceURI != null) {
    hydrated[_TransferrableKeys.TransferrableKeys.namespaceURI] = minimizeString(element.namespaceURI);
  }

  if (NODES_ALLOWED_TO_TRANSMIT_TEXT_CONTENT.includes(element.nodeType) && element.textContent !== null) {
    hydrated[_TransferrableKeys.TransferrableKeys.textContent] = minimizeString(element.textContent);
  }

  (0, _eventSubscription.applyDefaultInputListener)(workerContext, element);
  (0, _eventSubscription.sendValueChangeOnAttributeMutation)(workerContext, element);
  return hydrated;
}
/**
 * @param element
 */


function createHydrateableRootNode(element, config, workerContext) {
  const hydrateFilter = config.hydrateFilter || (() => true);

  const strings = [];
  const stringMap = new Map();

  const storeString = value => {
    if (stringMap.has(value)) {
      // Safe to cast since we verified the mapping contains the value.
      return stringMap.get(value);
    }

    const count = strings.length;
    stringMap.set(value, count);
    strings.push(value);
    return count;
  };

  const skeleton = createHydrateableNode(element, storeString, hydrateFilter, workerContext);
  return {
    skeleton,
    strings
  };
}
/**
 * @param element
 */


function createReadableHydrateableRootNode(element, config, workerContext) {
  // "Readable" variant doesn't do any string minimization so we can output it for debugging purposes.
  // Note that this intentionally breaks the type contract of createHydrateableNode() and HydrateableNode.
  return createHydrateableNode(element, value => value, config.hydrateFilter || (() => true), workerContext);
}
},{"../transfer/TransferrableNodes":"a60b7ec2b30b96d412926079ae916dec","../transfer/TransferrableKeys":"38ecb3927f64cad8acafe7b8b5601eb5","../utils":"b823de61bf5e9fca299c60d0b56af8c5","./commands/event-subscription":"d5f875a605c8e7c7352a153b4110f36e"}],"a609320500f9a22ea17dba0d7cfadb6b":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.readableMessageToWorker = readableMessageToWorker;
exports.readableTransferredNode = exports.readableHydrateableRootNode = void 0;

var _Messages = require("../transfer/Messages");

var _TransferrableNodes = require("../transfer/TransferrableNodes");

var _TransferrableKeys = require("../transfer/TransferrableKeys");

var _serialize = require("./serialize");

/**
 * Copyright 2018 The AMP HTML Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * @fileoverview Converts index-based worker messages to human-readable objects.
 *
 * Requires manual upkeep to keep consistency with messages and enums.
 * This allows us to continue using 'const enum' for enum inlining.
 * @see https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md#9.4
 */

/**
 * @param element
 */
const readableHydrateableRootNode = (element, config, workerContext) => readableHydrateableNode((0, _serialize.createReadableHydrateableRootNode)(element, config, workerContext));
/**
 * @param nodeContext {NodeContext}
 * @param node {TransferredNode}
 */


exports.readableHydrateableRootNode = readableHydrateableRootNode;

const readableTransferredNode = (nodeContext, node) => node != null && nodeContext.getNode(node[_TransferrableNodes.TransferrableNodeIndex.Index]) || node;
/**
 * @param node
 */


exports.readableTransferredNode = readableTransferredNode;

function readableHydrateableNode(node) {
  const out = {
    nodeType: node[_TransferrableKeys.TransferrableKeys.nodeType],
    name: node[_TransferrableKeys.TransferrableKeys.localOrNodeName],
    attributes: null,
    childNodes: null
  };
  const attributes = node[_TransferrableKeys.TransferrableKeys.attributes];

  if (attributes) {
    out.attributes = attributes.map(attr => ({
      name: attr[1],
      value: attr[2]
    }));
  }

  const childNodes = node[_TransferrableKeys.TransferrableKeys.childNodes];

  if (childNodes) {
    out.childNodes = childNodes.map(readableHydrateableNode);
  }

  return out;
}
/**
 * @param message {MessageToWorker}
 */


const isEvent = message => message[_TransferrableKeys.TransferrableKeys.type] == _Messages.MessageType.EVENT;

const isValueSync = message => message[_TransferrableKeys.TransferrableKeys.type] == _Messages.MessageType.SYNC;

const isBoundingClientRect = message => message[_TransferrableKeys.TransferrableKeys.type] === _Messages.MessageType.GET_BOUNDING_CLIENT_RECT;
/**
 * @param nodeContext {NodeContext}
 * @param event {TransferrableEvent}
 */


function readableTransferrableEvent(nodeContext, event) {
  const value = item => {
    if (typeof item === 'number' || typeof item === 'boolean') {
      return item !== undefined ? item : null;
    }

    return item !== undefined && item !== null ? readableTransferredNode(nodeContext, item) : null;
  };

  return {
    type: event[_TransferrableKeys.TransferrableKeys.type],
    bubbles: value(event[_TransferrableKeys.TransferrableKeys.bubbles]),
    cancelable: value(event[_TransferrableKeys.TransferrableKeys.cancelable]),
    cancelBubble: value(event[_TransferrableKeys.TransferrableKeys.cancelBubble]),
    defaultPrevented: value(event[_TransferrableKeys.TransferrableKeys.defaultPrevented]),
    eventPhase: value(event[_TransferrableKeys.TransferrableKeys.eventPhase]),
    isTrusted: value(event[_TransferrableKeys.TransferrableKeys.isTrusted]),
    returnValue: value(event[_TransferrableKeys.TransferrableKeys.returnValue]),
    currentTarget: value(event[_TransferrableKeys.TransferrableKeys.currentTarget]),
    target: value(event[_TransferrableKeys.TransferrableKeys.target]),
    scoped: value(event[_TransferrableKeys.TransferrableKeys.scoped]),
    keyCode: value(event[_TransferrableKeys.TransferrableKeys.keyCode])
  };
}
/**
 * @param nodeContext {NodeContext}
 * @param value {TransferrableSyncValue}
 */


function readableTransferrableSyncValue(nodeContext, value) {
  const index = value[_TransferrableKeys.TransferrableKeys.index];
  return {
    target: nodeContext.getNode(index) || index,
    value: value[_TransferrableKeys.TransferrableKeys.value]
  };
}
/**
 * @param message
 */


function readableMessageToWorker(nodeContext, message) {
  if (isEvent(message)) {
    const event = message[_TransferrableKeys.TransferrableKeys.event];
    return {
      type: 'EVENT',
      event: readableTransferrableEvent(nodeContext, event)
    };
  } else if (isValueSync(message)) {
    const sync = message[_TransferrableKeys.TransferrableKeys.sync];
    return {
      type: 'SYNC',
      sync: readableTransferrableSyncValue(nodeContext, sync)
    };
  } else if (isBoundingClientRect(message)) {
    return {
      type: 'GET_BOUNDING_CLIENT_RECT',
      target: readableTransferredNode(nodeContext, message[_TransferrableKeys.TransferrableKeys.target])
    };
  } else {
    return 'Unrecognized MessageToWorker type: ' + message[_TransferrableKeys.TransferrableKeys.type];
  }
}
},{"../transfer/Messages":"99507ba4e687c3fb9b635299dae9953c","../transfer/TransferrableNodes":"a60b7ec2b30b96d412926079ae916dec","../transfer/TransferrableKeys":"38ecb3927f64cad8acafe7b8b5601eb5","./serialize":"e5456ee0f968d64a068884d599db741d"}],"824b44ecae2781d5cd76b62ce5e155e2":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ObjectContext = void 0;

/**
 * Copyright 2019 The AMP HTML Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Stores objects that have their behavior handled from the main-thread. Each object is associated to a unique ID.
 */
class ObjectContext {
  constructor() {
    this.objects = new Map();
  }

  store(id, obj) {
    this.objects.set(id, obj);
  }

  get(id) {
    const obj = this.objects.get(id);

    if (obj) {
      return obj;
    } else {
      throw new Error('Object with id (' + id + ') does not exist.');
    }
  }

}

exports.ObjectContext = ObjectContext;
},{}],"10f1cd8b14791472d832b6a2e8ae57b6":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ExportedWorker = void 0;

var _function = require("./commands/function");

var _Messages = require("../transfer/Messages");

var _TransferrableKeys = require("../transfer/TransferrableKeys");

var _TransferrableMutation = require("../transfer/TransferrableMutation");

/**
 * Copyright 2020 The AMP HTML Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * An ExportedWorker is returned by the upgradeElement API.
 * For the most part, it delegates to the underlying Worker.
 *
 * It notably removes `postMessage` support and add `callFunction`.
 */
class ExportedWorker {
  constructor(workerContext, config) {
    this.workerContext_ = workerContext;
    this.config = config;
  }
  /**
   * Calls a function in the worker and returns a promise with the result.
   * @param functionIdentifer
   * @param functionArguments
   */


  callFunction(functionIdentifer, ...functionArguments) {
    if (!this.config.executorsAllowed.includes(_TransferrableMutation.TransferrableMutationType.FUNCTION_CALL)) {
      throw new Error(`[worker-dom]: Error calling ${functionIdentifer}. You must enable the FUNCTION_CALL executor within the config.`);
    }

    const {
      promise,
      index
    } = (0, _function.registerPromise)();
    const msg = {
      [_TransferrableKeys.TransferrableKeys.type]: _Messages.MessageType.FUNCTION,
      [_TransferrableKeys.TransferrableKeys.functionIdentifier]: functionIdentifer,
      [_TransferrableKeys.TransferrableKeys.functionArguments]: JSON.stringify(functionArguments),
      [_TransferrableKeys.TransferrableKeys.index]: index
    };
    this.workerContext_.messageToWorker(msg);
    return promise;
  }

  set onerror(handler) {
    this.workerContext_.worker.onerror = handler;
  }

  terminate() {
    this.workerContext_.worker.terminate();
  }

}

exports.ExportedWorker = ExportedWorker;
},{"./commands/function":"da8cdd19aabb35c9fec1b151586a109a","../transfer/Messages":"99507ba4e687c3fb9b635299dae9953c","../transfer/TransferrableKeys":"38ecb3927f64cad8acafe7b8b5601eb5","../transfer/TransferrableMutation":"d13bf1ec6ccac463f51d13cf5711f92b"}]},{},["64c1770b35b04eb343009bb27a752262","9e6c9279921cd7463bde46581d76eda7","bd665bee0b094abac42ce96c8f8b084d"], null)

//# sourceMappingURL=react-map.783678e2.js.map
