"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WorkerContext = void 0;

var _serialize = require("./serialize");

var _debugging = require("./debugging");

var _TransferrableKeys = require("../transfer/TransferrableKeys");

var _TransferrableStorage = require("../transfer/TransferrableStorage");

/**
 * Copyright 2018 The AMP HTML Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class WorkerContext {
  /**
   * @param baseElement
   * @param nodeContext
   * @param workerDOMScript
   * @param authorScript
   * @param config
   */
  constructor(baseElement, nodeContext, workerDOMScript, authorScript, config) {
    this.nodeContext = nodeContext;
    this.config = config;
    const {
      skeleton,
      strings
    } = (0, _serialize.createHydrateableRootNode)(baseElement, config, this);
    const cssKeys = [];
    const globalEventHandlerKeys = []; // TODO(choumx): Sync read of all localStorage and sessionStorage a possible performance bottleneck?

    const localStorageData = config.sanitizer ? config.sanitizer.getStorage(_TransferrableStorage.StorageLocation.Local) : window.localStorage;
    const sessionStorageData = config.sanitizer ? config.sanitizer.getStorage(_TransferrableStorage.StorageLocation.Session) : window.sessionStorage;

    for (const key in baseElement.style) {
      cssKeys.push(key);
    }

    for (const key in baseElement) {
      if (key.startsWith('on')) {
        globalEventHandlerKeys.push(key);
      }
    }

    const code = `
      'use strict';
      (function(){
        ${workerDOMScript}
        self['window'] = self;
        var workerDOM = WorkerThread.workerDOM;
        WorkerThread.hydrate(
          workerDOM.document,
          ${JSON.stringify(strings)},
          ${JSON.stringify(skeleton)},
          ${JSON.stringify(cssKeys)},
          ${JSON.stringify(globalEventHandlerKeys)},
          [${window.innerWidth}, ${window.innerHeight}],
          ${JSON.stringify(localStorageData)},
          ${JSON.stringify(sessionStorageData)}
        );
        workerDOM.document[${_TransferrableKeys.TransferrableKeys.observe}](this);
        Object.keys(workerDOM).forEach(function(k){self[k]=workerDOM[k]});
      }).call(self);
      ${authorScript}
      //# sourceURL=${encodeURI(config.authorURL)}`;
    this[_TransferrableKeys.TransferrableKeys.worker] = new Worker(URL.createObjectURL(new Blob([code])));

    if (undefined) {
      console.info('debug', 'hydratedNode', (0, _debugging.readableHydrateableRootNode)(baseElement, config, this));
    }

    if (config.onCreateWorker) {
      config.onCreateWorker(baseElement, strings, skeleton, cssKeys);
    }

    if (config.messageChannel) {
      this[_TransferrableKeys.TransferrableKeys.worker].addEventListener("message", e => config.messageChannel?.port2.postMessage(e.data, [e.data]));
    }
  }
  /**
   * Returns the private worker.
   */


  get worker() {
    return this[_TransferrableKeys.TransferrableKeys.worker];
  }
  /**
   * @param message
   */


  messageToWorker(message, transferables) {
    if (undefined) {
      console.info('debug', 'messageToWorker', (0, _debugging.readableMessageToWorker)(this.nodeContext, message));
    }

    if (this.config.onSendMessage) {
      this.config.onSendMessage(message, transferables || []);
    }

    if (this.config.messageChannel) {
      this.config.messageChannel.port1.postMessage(message, transferables || []);
    }

    this.worker.postMessage(message, transferables || []);
  }

}

exports.WorkerContext = WorkerContext;